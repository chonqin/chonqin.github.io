[{"title":"11月的碎碎念","url":"/year/11/08/11月的碎碎念/","content":"\n# 11月初\n\n\n\n10月底到11月真的好多事情，线代考试、机原考试、dx那边还有作业要写、实验室那边还有点任务，课内的东西真的不想学啊，感觉全没啥用。。。\n\nTMD的，给兄弟找到女朋友了，不过也正常，那女生追了一年多，终于成了吗？\n\n现在就业真的越来越烂了，以前实习都很好找的，现在找个实习困难的要死，实验室的师兄那么有实力都只能去找测试的实习，哎。。。\n\n目前，整体感觉还不错，有空跑跑步，然后不断学习进步，可惜少个女朋友。\n\n但是，不主动哪有人看上我，算了吧，一个人也挺好。\n","tags":["碎碎念"],"categories":["碎碎念"]},{"title":"ROS-raspi","url":"/year/11/03/ROS-raspi/","content":"\n\n\n# 树莓派ROS小车\n\n## 安装树莓派相关ROS环境\n\n### 安装ubuntu mate系统\n\n#### 下载ubuntu mate20.04镜像\n\n- 百度搜索ubuntu mate，进入download界面，拉倒最底下\n\n- 选择Browse archive and previous device ports https://releases.ubuntu-mate.org/\n\n![image-20251023165941768](./ROS-raspi/image-20251023165941768.png)\n\n![image-20251023170041982](./ROS-raspi/image-20251023170041982.png)\n\n- 随后进入20.04 arm64 ，下载https://releases.ubuntu-mate.org/20.04/arm64/ubuntu-mate-20.04.1-desktop-arm64+raspi.img.xz\n\n![image-20251023170222972](./ROS-raspi/image-20251023170222972.png)\n\n#### 制作并烧录到SD卡里\n\n- 前往树莓派官网下载他的烧录工具\n\n![image-20251023170412766](./ROS-raspi/image-20251023170412766.png)\n\n- 第一个选择烧录的设备型号（树莓派4B），第二个选择自己下载的ubuntu mate ，第三个选择烧录的位置，选择你的sd卡。随后点击烧录即可\n\n    ![image-20251023170559247](./ROS-raspi/image-20251023170559247.png)\n\n- 可以提前配置一下用户名、网络啥的。\n\n\n\n#### 进入树莓派ubuntu mate系统\n\n把sd卡插入树莓派，随后插电开机。使用micro HDMI线连上显示器。\n\n进行基本的配置，设置用户名密码、网络连接。\n\n更换清华源，不再赘述。\n\n安装network工具\n\n```shell\nsudo apt install net-tools\n```\n\n查看树莓派的ip\n\n```shell\nifconfig\n```\n\n![image-20251023171300357](./ROS-raspi/image-20251023171300357.png)\n\n将树莓派和主机放在同一局域网，测试ping通，在主机终端输入\n\n```shell\nping 10.43.234.55(树莓派ip)\n```\n\n![image-20251023171505520](./ROS-raspi/image-20251023171505520.png)\n\n这样就是ping通了，可以使用远程连接。\n\n### 树莓派配置远程连接\n\n#### ssh连接\n\n**直接终端连接**：\n\n在ubuntu主机里，下载remmina连接工具。\n\nping通了之后，终端可以直接连，但是使用remmina工具更方便。\n\n终端输入ssh <树莓派用户名>@<树莓派IP地址>\n\n```shell\nshh pi@10.43.234.55\n```\n\n![image-20251023171926032](./ROS-raspi/image-20251023171926032.png)\n\n输入树莓派密码后就可以连接上了。\n\n**利于remmina**：\n\n这是linux下一个软件能储存信息，方便连接：\n\n点击左上角加好，再输入ip 密码啥的就可以连接了。\n\n![image-20251025164851196](./ROS-raspi/image-20251025164851196.png)\n\n#### 利用TigerVNC进行远程桌面连接\n\n先给ubuntu mate换个桌面，自带的mate桌面有点卡。\n\n更换xfce4桌面并卸载自带mate桌面不赘述了（自行搜索）。\n\n![image-20251025165110719](./ROS-raspi/image-20251025165110719.png)\n\n### 个人IP\n\n`校园网环境下`：\n\n​\tPC有线连接校园网IP：10.43.173.38\n\n​\t树莓派无线连接宿舍校园网IP：10.43.234.55\n\n`609wifi环境下`:\n\n​\tPC有线连接校园网IP：10.43.173.38\n\n​\t树莓派无线连接宿舍校园网IP：10.43.234.55\n\n\n\n\n\n### sync同步文件的使用\n\n**基本用法**:\n\n- 路径在左边：意味着将左边同步到右边\n- 路径在右边：同理\n\n```shell\nsync <本地路径> <远程连接用户名>@<IP地址>:<远程路径>\n# 注意空格，路径写全不要用~\n```\n\n**sync同步命令是一次性的，每次输入都很长，很麻烦，编写一个脚本来实现**：\n\n```shell\n# 树莓派目标目录\nREMOTE_DIR=/home/pi/pi_ws/src\n\necho \"===============================\"\necho \"  选择要同步的树莓派\"\necho \"===============================\"\n\n# 显示菜单\nindex=1\nfor name in \"${!PI_HOSTS[@]}\"; do\n    echo \"$index. $name  (${PI_HOSTS[$name]})\"\n    names[$index]=$name\n    ((index++))\ndone\n\n# 用户输入编号\nread -p \"请输入编号 (1-$((index-1))): \" choice\n\nif [[ -z \"${names[$choice]}\" ]]; then\n    echo \"无效的编号，退出。\"\n    exit 1\nfi\n\n# 获取选择的名称和IP\nSELECTED_NAME=${names[$choice]}\nPI_HOST=${PI_HOSTS[$SELECTED_NAME]}\n\necho \"\"\necho \"\t\t已选择: $SELECTED_NAME ($PI_HOST)\"\necho \"    本地目录:  $LOCAL_DIR/\"\necho \"    目标目录:  $PI_USER@$PI_HOST:$REMOTE_DIR/\"\necho \"\"\n\n# 二次确认\nread -p \"确认执行同步吗？(y/n): \" confirm\nif [[ \"$confirm\" != \"y\" && \"$confirm\" != \"Y\" ]]; then\n    echo \"已取消同步。\"\n    exit 0\nfi\n\n# 检查设备是否在线\nping -c 1 -W 1 \"$PI_HOST\" &>/dev/null\nif [[ $? -ne 0 ]]; then\n    echo \"无法连接到 $PI_HOST，请检查网络。\"\n    exit 1\nfi\n\n# Rsync 同步\nrsync -avz --progress \"${LOCAL_DIR}/\" \"${PI_USER}@${PI_HOST}:${REMOTE_DIR}/\"\n\necho \"同步到 $SELECTED_NAME 完成\"\n# --progress 命令可以中显示文件传输进度条，包括文件大小、已经传输的大小、传输速度和剩余时间\n```\n\n- -a———>保留文件属性并递归复制目录\n- -v———>显示详细信息\n- -z———>压缩数据，加快传输\n- --progress———>显示每个文件传输进度\n\n## ROS与STM32间的通信\n\n### 完成hello world!\n\n首先，让STM32F407串口发送一个**\"hello world!\"**\n\nlinux下串口工具可以使用xTools：\n\n![image-20251025165649697](./ROS-raspi/image-20251025165649697.png)\n\ncutecom在我的环境下有显示的问题，不使用。\n\n查询串口：\n\n```shell\nls /dev/tty*\n```\n\n![image-20251025170343631](./ROS-raspi/image-20251025170343631.png)\n\n**可以通过插拔来查找usb串口通道**\n\nlinux系统下串口无法使用问题：\n\n- 没有安装usb转ttl的驱动导致问题\n- 没有给予usb权限\n\n解决方法：\n\n- 去下载对应芯片的驱动（ch340/ch9102）,linux自带了cp210x的驱动\n- 使用chmod给对应串口通道施加权限，没有权限无法运行。\n\n```shell\nchmod 777 <设备通道>\neg:\nchmod 777 /dev/ttyUSB0\n```\n\nros串口发布节点：\n\n```c++\n#include \"ros/ros.h\"\n#include \"std_msgs/String.h\"\n#include \"serial/serial.h\"\n\nserial::Serial ser;\nvoid serial_init() {\n    ser.setPort(\"/dev/ttyUSB0\");//串口名称\n    ser.setBaudrate(115200);//波特率\n    serial::Timeout to = \t\t\t\t  \t\t\t\t\tserial::Timeout::simpleTimeout(100);//等待时间\n    ser.setTimeout(to);\n\n    try {\n        ser.open();//打开串口\n    }\n    catch(serial::IOException& e){\n        ROS_ERROR_STREAM(\"Unable to open port.\");\n    }\n    if (ser.isOpen()) {\n        ROS_INFO(\"/dev/ttyCH341USB0 is open\");\n    }\n    else {\n        ROS_ERROR(\"/dev/ttyCH341USB0 open failed.\");\n    }\n}\nint main(int argc, char **argv) {\n    //ROS初始化\n    ros::init(argc, argv, \"stm32_Serial_test01\");\n    ros::NodeHandle nh;\n    //创建ROS发布者节点\n    ros::Publisher stm32_pub = nh.advertise<std_msgs::String>(\"stm32_data\", 10);\n    //串口相关配置\n    serial_init();\n    ros::Rate loop_rate(10);//设置循环速率\n    while(ros::ok())\n    {\n        //获取缓冲区内的字节数\n        size_t n = ser.available();\n        if (n != 0)\n        {\n            //定义一个缓冲区，将数据存放在此\n            uint8_t buffer[1024];\n            n = ser.read(buffer, n);\n\n            std::string received_data(buffer, buffer + n);  // 将字节转成字符串\n            ROS_INFO_STREAM(\"Received data: \" << received_data);\n            //将接受到的内容封装为ROS消息，并发布消息出去\n            std_msgs::String msg;\n            msg.data = received_data;\n            stm32_pub.publish(msg);\n\n            if (received_data.find(\"hello world!\") != std::string::npos) {\n                ROS_INFO(\"STM32 sent: hello world!\");\n            }\n        }\n        ros::spinOnce();\n        loop_rate.sleep();\n    }\n    ser.close();\n    return 0;\n}\n```\n\n设置stm32串口发送到上位机后，开启此节点，可以看到成功接收。\n\n## 编写键盘输入节点实现键盘控制小车移动\n\n### 键盘输入节点\n\n核心是如何读取键盘输入，然后转换成数据发送话题出去\n\n```c++\n// ----------- 函数功能：从终端读取单个按键，不需要按回车 ----------- //\nint getch() {\n    struct termios oldt, newt;\n    int ch;\n\n    // 获取当前终端属性\n    tcgetattr(STDIN_FILENO, &oldt);\n    newt = oldt;\n\n    // 关闭规范模式(ICANON)和回显(ECHO)，实现即时单字符读取\n    newt.c_lflag &= ~(ICANON | ECHO);\n    tcsetattr(STDIN_FILENO, TCSANOW, &newt);\n\n    // 读取单个字符\n    ch = getchar();\n\n    // 恢复终端原设置\n    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);\n\n    return ch;\n}\nint main(int argc, char** argv) {\n    // 初始化 ROS 节点，节点名为 keyboard_ctrl_pub\n    ros::init(argc, argv, \"keyboard_control\");\n    ros::NodeHandle nh;\n\n    // 创建 Publisher，发布主题为 /cmd_vel，消息类型为 geometry_msgs::Twist\n    ros::Publisher cmd_pub = nh.advertise<geometry_msgs::Twist>(\"cmd_vel\", 10);\n\n    geometry_msgs::Twist cmd;  // 创建 Twist 消息对象\n\n    std::cout << \"\\n=== 键盘控制说明 ===\\n\";\n    std::cout << \"w: 前进 | s: 后退 | a: 左转 | d: 右转\\n\";\n    std::cout << \"空格: 停止 | q: 退出程序\\n\";\n    std::cout << \"====================\\n\";\n\n    // 主循环：持续读取键盘按键\n    while (ros::ok()) {\n        int c = getch();  // 获取键盘输入\n\n        // 每次先清零速度\n        cmd.linear.x = 0.0;\n        cmd.angular.z = 0.0;\n\n        // 按键控制逻辑\n        if (c == 'w') {\n            cmd.linear.x = 0.5;     // 前进，线速度为 0.5 m/s\n        } else if (c == 's') {\n            cmd.linear.x = -0.5;    // 后退\n        } else if (c == 'a') {\n            cmd.angular.z = 1.0;    // 左转，角速度正方向\n        } else if (c == 'd') {\n            cmd.angular.z = -1.0;   // 右转，角速度负方向\n        } else if (c == ' ') {\n            cmd.linear.x = 0;       // 停止\n            cmd.angular.z = 0;\n        } else if (c == 'q') {\n            // 按 q 退出程序\n            std::cout << \"退出程序\\n\";\n            break;\n        }\n\n        // 发布速度命令\n        cmd_pub.publish(cmd);\n\n        // 打印调试信息\n        ROS_INFO(\"发布速度: linear=%.2f m/s, angular=%.2f rad/s\", cmd.linear.x, cmd.angular.z);\n    }\n\n    return 0;\n}\n```\n\n编写了这个控制节点后，成功将数据利用话题的方式发布出去。\n\n### 通信节点\n\n前面写了键盘并且把\n","tags":["ROS","raspi"],"categories":["学习","ROS"]},{"title":"ROS基础","url":"/year/11/03/ROS基础/","content":"\n\n# ROS\n\n## 前言\n\n使用的ros版本为Noetic版本，基于Ubuntu20.04.6\n\n## ros是什么\n\n- ROS：Robot Operating System\n- 包括了四个part：通信机制、开发工具、应用功能、生态系统\n- 这种模式旨在提高机器人研发中的软件复用率\n\n### 节点(Node) 与 节点管理器(Node Master)\n\n![img](./ROS基础/e4cf4abf66181a4b6c4d6ccd5ff8c5e9.png)\n\n### 2.通信模式之一——Topic模式\n\n![img](./ROS基础/6b5151a88a7d50ae4b4ac6e995fbe274.png)\n\n- Message：定义数据的类型，具有一定的数据结构定义\n- 单向的，可多次\n- 数据的管道称为Topic（话题）\n- 使用 发布&订阅 模型，右下图显示了Camera Node是发布者，图像处理节点和图像显示节点是订阅者。\n- 话题的消息的接口使用 .msg 文件定义\n\n### 通信模式之二——Service模式\n\n![在这里插入图片描述](./ROS基础/5526214ed935d789e03d828b463f0ad4.png)\n\n- C/S模型\n- 带有反馈的机制\n- 双向的，来往一次\n- 如左下图，图像处理节点向Camera节点发出请求（比如上调图像分辨率），Camera节点上调分辨率后向图像处理节点发出反馈。\n- 服务的数据内容可用 .srv 自定义\n\n### 两者对比\n\n![img](./ROS基础/5797a3624420670cdd2c0962a3a6efcb.png)\n\n### 参数(Parameter)\n\n![在这里插入图片描述](./ROS基础/a43896255ea289882e9ec61987f5cf2f.png)\n\n- 参数是一个“字典”\n- 存储在ROS Master服务器，节点可以对参数存储、检索、更新（如图）\n- 适合静态存储、非二进制\n\n## 文件系统\n\n![在这里插入图片描述](./ROS基础/f92abef3679ce9fee72cd879d885ff98.png)\n\n- 文件系统代表了代码的结构\n\n## ROS命令行工具\n\n###  回顾第一个小海龟程序\n\n打开小海龟程序：\n 终端，启动ROS Master：\n\n```powershell\nroscore\n```\n\n终端2，启动小海龟仿真器：\n （输入`rosrun turtlesim`，敲两下`Tab`健可查看该命令下有哪些功能）\n\n```powershell\nrosrun turtlesim turtlesim_node\n```\n\n终端3，启动海龟控制节点：\n\n```powershell\nrosrun turtlesim turtle_teleop_key\n```\n\n![在这里插入图片描述](./ROS基础/697323cffea407d3f72f3cdaee58a02a.png)\n\n### 查看系统中的计算图：rqt_graph\n\n新建终端窗口：\n\n```powershell\nrqt_graph\n```\n\n可展示系统中运行的计算图：\n ![在这里插入图片描述](./ROS基础/99b2537f738a69cc0a22ab5e3a82acbc.png)可以清晰地了解系统节点间通信的部分信息。\n teleop_turtle节点（键盘控制节点）通过cmd_vel（[topic](https://so.csdn.net/so/search?q=topic&spm=1001.2101.3001.7020)）向turtlesim节点（海归仿真器节点）发出消息，使得小海龟移动。\n\n### rosnode\n\n#### 显示节点列表：rosnode list\n\n![在这里插入图片描述](./ROS基础/925ad456811072eabab0b16e704def72.png)可以看到有3个节点。\n\n#### 查看节点信息：rosnode info\n\n查看节点的具体信息：`rosnode info /节点名`\n 我们查看海龟仿真器节点/turtlesim的信息：\n ![在这里插入图片描述](./ROS基础/6f3eb2ad18e3173f7adc066991ce6d41.png)\n 可以看到海龟仿真器节点/turtlesim自己有一些发布和订阅，也有一些服务。\n\n### rostopic\n\n#### 显示topic列表：rostopic list\n\n![在这里插入图片描述](./ROS基础/ab34938183af1424055c4a3c20159ea7.png)\n\n#### 手动发布数据给topic\n\n我们来手动发布数据给topic来控制海龟移动，使用`rostopic pub`\n 上图我们看到小海龟是通过/cmd_vel这个topic进行发布信息而移动的，这次我们通过手动publish数据给这个topic来控制小海龟移动。\n 格式：`rostopic pub (参数) 话题名 消息数据结构 “具体数据”`\n 例，我们输入：（我们可以使用Tab键让我们自动填充数据，使用方向键←→移动到指定位置修改数据，比如我们把x的0.0改成了1.0）\n\n```powershell\nrostopic pub /turtle1/cmd_vel geometry_msgs/Twist \"linear:\n  x: 1.0\n  y: 0.0\n  z: 0.0\nangular:\n  x: 0.0\n  y: 0.0\n  z: 0.0\"\n```\n\n小海龟沿着正前方向移动了1单位，我们再使用参数`-r 5`移动5次，小海龟就撞上了南墙。\n Ctrl+C就可以终止。\n ![在这里插入图片描述](./ROS基础/000001a66bd5d198841ecc3c559f628b.png)\n\n### rosmsg\n\n#### 查看消息数据结构\n\n上例我们使用了**消息数据结构**定义了一个消息传给topic，我们可以查看有哪些消息数据结构。\n 查看消息数据结构使用：rosmsg show …\n 在输入过程中，我们可以勤使用Tab键查看或填充内容。\n ![在这里插入图片描述](./ROS基础/a446daca224d4bc77e761ef2692c3a45.png)我们可以看到geometry_msgs/Twist数据结构的内容。\n\n### 使用服务[通信方式](https://so.csdn.net/so/search?q=通信方式&spm=1001.2101.3001.7020)：rosservice\n\n上例我们使用了向topic传msg来控制节点，这次我们试试第二种通信方式service。\n\n#### 查看服务列表：rosservice list\n\n![在这里插入图片描述](./ROS基础/32719771b899013c1c6ac95849ddcdb5.png)\n\n#### 手动通过服务来进行操作\n\n这次我们通过人工产生服务（service）来诞生一只新海龟，使用rosservice call /spawn …\n 在服务列表中，有个/spawn服务，可以产生一只新的海龟。\n 格式：`rosservice call (参数) 服务名 “具体数据”`\n ![在这里插入图片描述](./ROS基础/db80ee57a72b73228a2a1050d5cb6ed9.png)\n 这时我们再输入`rostopic list`，可以看到turtle2已经在topic里了。\n\n### 话题记录和复现：rosbag\n\n试想我们尝试让海龟以我们指定的路径移动了一回，我们想要把它 记录下来，拷贝到自己的实验室再复现出来，我们就可以使用话题记录功能。\n 常用命令：`rosbag record -a -O 文件名`\n 比如我们使用之前打开的键盘操作器让海龟移动一圈并记录下来：\n （1）打开新终端输入`rosbag record -a -O cmd_record`\n 这样就开始记录了：\n ![在这里插入图片描述](./ROS基础/8c34c3e8ba55b97fef872094a0e9967e.png)（2）移动一下：\n ![在这里插入图片描述](./ROS基础/d4a97523dd1e02ba3d9f3de572cc0ddd.png)到记录界面按Ctrl+C停止：\n ![在这里插入图片描述](./ROS基础/ab9d48b8d0bb0f1958b197bcc8102c3f.png)文件就记录在了这里：![在这里插入图片描述](./ROS基础/02513d9713deb389df68bf2e412308d9.png)\n （3）接下去关闭所有打开的ros节点\n 重新开启roscore，开启海龟节点rosrun turtlesim turtlesim_node\n 这时我们输入 `rosbag play cmd_record`就可以复现之前的移动啦！\n ![在这里插入图片描述](./ROS基础/f2b14c6c527a5afe88585f93ceed7931.png)\n\n## 创建ros工作空间与功能包\n\n###  1.What is Workspace(工作空间)\n\n工作空间（Workspace）：存放工程开发相关文件的文件夹。类似一个IDE（例如Pycharm）新建一个工程，就是一个工作空间。包含4个文件夹：\n\n- src：代码空间（Source Space）：放置功能包代码\n- build：编译空间（Build Space）：编译过程中产生的中间文件，不用过多关注\n- devel：开发空间（Development Space）：放置编译生成的可执行文件、库、脚本\n- install：安装空间（Install Space）：存放可执行文件，与上面有一定重复\n\n### 2 .创建工作空间\n\n#### 创建:\n\n```\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/src \t\t//进入路径\ncatkin_init_workspace\t//创建\n```\n\n我们先创建一个src文件夹，然后进入该文件夹\n第3行catkin_init_workspace意为将当前文件夹变为工作空间，使其拥有工作空间的属性\n\n注：“~/”意为当前用户名目录；“-p”意为递归创建目录，即直接创建多级目录。\nsrc文件夹即代码空间，**不能自行用别的名称代替**\n\n![img](./ROS基础/295b716b8c61ab30db59a08f20365092.png)可以看到创建了这么一个txt文件，说明创建工作空间成功。\n\n#### 编译空代码的工作空间\n\n要编译工作空间，先要回到工作空间的根目录。\n\n```powershell\ncd ~/catkin_ws //\ncatkin_make\n```\n\n使用catkin_make为编译指令，将src里的源码进行编译\n\n![img](./ROS基础/200bc54200a700eaebfd9d1884fc8b08.png)\n\n可以看到生成了build和devel两个新文件夹，devel存放了编译完成的内容。\n 这里没有生成install文件夹，要生成install文件夹，输入`catkin_make install`：\n\n![在这里插入图片描述](./ROS基础/a0d7c51839653be7056a87d3248cea71.png)\n\ninstall中生成了可执行文件。\n\n这样一个空的工作空间创建好了，并且空的代码空间（功能包）编译完成。\n\n### 创建功能包\n\n**功能包**是放置ROS源码的最小单元。\n\n上面我们创建了一个空的工作空间，src文件夹里面没写东西，现在我们创建一个自己的功能包。\n\n**注意同一工作空间下，不允许存在同名功能包；不同工作空间下，允许存在同名功能包**。\n\n指令格式：**catkin_create_pkg <package_name> [depend1] [depend2] [depend3]**\n\n<package_name>为包名\n\n[depend]为依赖，即指明编译的时候需要ROS中的其他功能包，如需要调用python、C++库，就要指明rospy、roscpp\n\n```powershell\ncd ~/catkin_ws/src\ncatkin_create_pkg test_pkg std_msgs rospy roscpp\n```\n\n创建后记得编译一下。\n\n### 设置并检查环境变量\n\n编译完功能包后，为了运行，先[设置环境变量](https://so.csdn.net/so/search?q=设置环境变量&spm=1001.2101.3001.7020)，以便系统找到我们的工作空间和功能包。\n\n```powershell\nsource ~/catkin_ws/devel/setup.bash\n```\n\n检查：\n\n```powershell\necho $ROS_PACKAGE_PATH\n```\n\n## 发布者Publisher的编程实现\n\n编程publisher 发送 message 产生topic，让海龟（sub）订阅实现功能。\n\n进入src，创建功能包。\n\n```powershell\ncatkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim\n```\n\n### 如何实现一个发布者程序：\n\n- 初始化ROS节点\n- 向ROS Master 注册节点信息，包括话题名和话题数据类型\n- 创建消息数据\n- 按照一定频率循环发布消息\n\n### 具体操作如下：\n\n- 先在src目录下创建源文件（c++/Python）\n\n- 编写程序，修改cmakelist文件，回到工作空间编译并source\n- 终端运行roscore，再打开一个终端运行rosrun +功能包下的程序\n- 最终能看到小海龟按设定的程序运动\n\n### 具体程序如下：\n\n```c++\n#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n\nint main(int argc, char **argv)\n{\n\t// ROS节点初始化\n\tros::init(argc, argv, \"velocity_publisher\");\n\t// 创建节点句柄\n\tros::NodeHandle n;\n\t// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10\n\tros::Publisher turtle_vel_pub = n.advertise<geometry_msgs::Twist>(\"/turtle1/cmd_vel\", 10);\n\n\t// 设置循环的频率\n\tros::Rate loop_rate(10);\n\n\tint count = 0;\n\twhile (ros::ok())\n\t{\n\t    // 初始化geometry_msgs::Twist类型的消息\n\t\tgeometry_msgs::Twist vel_msg;\n\t\tvel_msg.linear.x = 0.5;\n\t\tvel_msg.angular.z = 0.2;\n\t    // 发布消息\n\t\tturtle_vel_pub.publish(vel_msg);\n\t\tROS_INFO(\"Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]\", vel_msg.linear.x, vel_msg.angular.z);\n\t    // 按照循环频率延时\n\t    loop_rate.sleep();\n\t}\n\treturn 0;\n}\n```\n\n## 订阅者Sub的实现\n\n- 初始化ROS节点\n- 订阅需要的话题\n- 循环等待话题消息，接收到消息后进入回调函数\n- 在回调函数中完成消息处理\n\n操作和上面pub一样\n\n### 程序如下\n\n```c++\n#include <geometry_msgs/Twist.h>\n#include <ros/init.h>\n#include <ros/node_handle.h>\n#include <ros/subscriber.h>\n#include <turtlesim/Pose.h>\nvoid poseCallback(const turtlesim::Pose::ConstPtr& msg) {\n    ROS_INFO(\"turtle pose : x :%0.6f, y :%0.6f\",msg->x,msg->y);\n}\n\nint main(int argc, char **argv) {\n    //ros初始化\n    ros::init(argc, argv, \"pose_subscriber\");\n    //创建节点的句柄\n    ros::NodeHandle n ;\n    //创建一个Subscriber，订阅名为/turtle/pose,注册回调函数poseCallback\n    ros::Subscriber pose_sub = n.subscribe(\"/turtle1/pose\", 10 , poseCallback) ;\n    //循环等待回调函数\n    ros::spin();\n\n    return 0;\n}\n```\n\n此程序可以读取小海龟的位置\n\n\n\n\n\n\n\n将pub和sub结合起来后的效果就是，海龟沿着设定的运动，然后sub获取他的位置\n\n\n\n使用rqt-graph进行查看\n\n![image-20250919211003647](./ROS基础/image-20250919211003647.png)\n\n## 话题消息的定义和使用\n\n- Message 是一种自定义的数据结构，用于话题间的数据存储和传输\n\n\n\n- 之前两节使用了Topic模型，我们先使用了Twist类型（geometry_msgs.msg库下的Twist类）的Message作为输入指令进行发布，接着使用了Pose类型（Turtlesim.msg库下的Pose类）的Message作为订阅消息进行接收。\n\n  ​    \n\n    使用rosmsg show命令查看\n\n    ![image-20250920110325714](./ROS基础/image-20250920110325714.png)\n\n    以上的**Message**消息都是预定义好的，当我们需要自定义消息该怎么做呢？\n\n如何操作：\n\n- 创建msg文件\n\n    进入功能包目录里，新建msg文件夹，将所有自定义msg文件放入里面\n\n    使用touch命令新建一个msg文件，将定义的东西放入msg中\n\n    ```powershell\n    touch Person.msg//P要大写\n    ```\n\n    ![image-20250920105335067](./ROS基础/image-20250920105335067.png)\n\n- 在package.xml添加功能包依赖\n\n    将以下两行粘贴进入文件内\n\n```\n<build_depend>message_generation</build_depend>\n<exec_depend>message_runtime</exec_depend>\n```\n\n\n\n- 在cmakelist中也要更改编译选项，把自定义msg文件添加到编译环境中\n\n    ```\n    find_package( ...... message_generation)\n    \n    add_message_files(FILES Person.msg)\n    generate_messages(DEPENDENCIES std_msgs)\n    \n    catkin_package( ...... message_runtime)\n    ```\n\n    说明如下：\n\n    \n\n    - 因为在package.xml添加了功能包编译依赖，在CMakeList.txt里的find_package中也要加上对应的部分；\n\n    - 需要将定义的Person.msg作为消息接口，针对它做编译；\n        需要指明编译这个消息接口需要哪些ROS已有的包；\n    - 有了34这两个配置才可将定义的msg编译成不同的程序文件\n    - 因为在package.xml添加了功能包执行依赖，在CMakeList.txt里的catkin_package中也要加上对应的部分\n\n- 最后回到工作空间进行编译\n\n## Servce模式的编程与使用\n\n![image-20250920173350676](./ROS基础/image-20250920173350676.png)\n\nSever端是海龟仿真器节点，Client端是等待实现的节点，产生Request的请求，发送给Sever端。Sever端接受请求后产生一只海龟，并返回Response。中间传输的数据结构为定义好的turtlesim：：Spawn。\n\n\n\n- 老样子，创建一个learing_servce的pkg，添加必要的依赖\n\n- 新建一个c++文件，放入src目录下\n\n- 更改cmakelist文件的编译选项，编译文件\n\n- 开启roscore，进行rosrun，实现功能\n\n    ### 程序如下\n\n    ```c++\n    int main(int argc, char** argv)\n    {\n        // 初始化ROS节点\n    \tros::init(argc, argv, \"turtle_spawn\");\n    \n        // 创建节点句柄\n    \tros::NodeHandle node;\n    \n        // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service\n    \tros::service::waitForService(\"/spawn\");\n    \tros::ServiceClient add_turtle = node.serviceClient<turtlesim::Spawn>(\"/spawn\");\n    \n        // 初始化turtlesim::Spawn的请求数据\n    \tturtlesim::Spawn srv;\n    \tsrv.request.x = 2.0;\n    \tsrv.request.y = 2.0;\n    \tsrv.request.name = \"turtle2\";\n    \n        // 请求服务调用\n    \tROS_INFO(\"Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]\", \n    \t\t\t srv.request.x, srv.request.y, srv.request.name.c_str());\n    \n    \tadd_turtle.call(srv);\n    \n    \t// 显示服务调用结果\n    \tROS_INFO(\"Spwan turtle successfully [name:%s]\", srv.response.name.c_str());\n    \n    \treturn 0;\n    };\n    \n    ```\n\n    ![image-20250920165919601](./ROS基础/image-20250920165919601.png)\n\n启动turle_spawn后，可以看到先是等待service应答\n\n随后开启turtlrsim节点后，服务应答，就在对应位置添加了一个新的小海龟\n\n![image-20250920170115886](./ROS基础/image-20250920170115886.png)\n\n## 服务端Sever的编程实现\n\n![image-20250920174015847](./ROS基础/image-20250920174015847.png)\n\nServer端本身是进行模拟海龟运动的命令端，它的实现是通过给海龟发送速度（Twist）的指令，来控制海龟运动（本身通过Topic实现）。\n\nClient端相当于海龟运动的开关，其发布Request来控制Server端。\n通过自定义名为 /turtle_command 的Service实现，中间传输消息的数据类型为std_srvs::Trigger（一种针对服务标准std_srvs下的数据定义）来通信。Trigger意为触发，通过Trigger信号来触发Server端的运动指令。\nServer端接收这个Trigger信号后，可控制其是否要给海龟发送Twist指令，同时给Client发送Response反馈告诉它海龟的运动状态\n\n\n\n![img](./ROS基础/b71bbe429ce84281c88ef0c910dd78f8.png)\n\n开启rosmaster，turtlesim之后\n\n 接着我们使用`rosservice call ...`请求海龟动起来，再打开一个终端。\n （输入完 /turtle_command 后敲个空格再用Tab键可自动填充空指令内容）\n\n```powershell\nrosservice call /turtle_command \"{}\"\n```\n\n就可以看到海龟动起来了\n\n\n\n## 服务数据srv的使用\n\n在第8节我们讲解了话题消息msg的定义与使用，在第8节的例子中我们曾自定义了一个消息类型“Person”以发布个人信息，Publisher发布个人信息，Subscriber接收个人信息。\n\n这个例子中，Publisher会不断地发信息，Subscriber不停地接数据，一开动就停不下来了，也是topic模式的缺陷。\n\n本节我们使用Service模式用自定义的服务数据srv来实现，我们希望Request一次才发一次信息来显示。\n\n### 创建srv文件\n\n在pkg功能包目录下创建srv文件夹，并使用touch命令生成.srv文件\n\n![image-20250922190659468](./ROS基础/image-20250922190659468.png)\n\n在文件中写入数据结构的内容\n\n```\nstring name\nuint8 sex\nuint8 age\n\nuint8 unknown = 0\nuint8 male = 1\nuint8 female = 2\n---\nstring result\n//与之前Person.msg不同的是，多了破折号下面这个Response结果，上面的是Request内容。\n//定义好srv数据接口后，就可以根据这个定义用C++或Python编译\n```\n\n### 添加功能包依赖\n\n由于此srv是自定义的，最初创建的时候没有添加依赖，所以要手动修改package.xml文件添加依赖。找到文件，把下面复制进去就好了。\n\n```\n<build_depend>message_generation</build_depend>\n//添加编译依赖\n<exec_depend>message_runtime</exec_depend>\n//添加执行依赖\n```\n\n### 添加编译选项\n\n打开CMakeLists.txt，添加编译选项，才能顺利的把srv文件编译出来。\n\n大致上为四条，找到对应的部分进行更改即可。\n\n每一部分都有注释在上方进行介绍。\n\n```\nfind_package( ...... message_generation)\n\nadd_service_files(FILES Person.srv)\ngenerate_messages(DEPENDENCIES std_msgs)\n\ncatkin_package( ...... message_runtime)\n\n```\n\n还得把自己写的cpp文件添加进去编译\n\n```\nadd_executable(person_server src/person_server.cpp)\ntarget_link_libraries(person_server ${catkin_LIBRARIES})\nadd_dependencies(person_server ${PROJECT_NAME}_gencpp)\n\nadd_executable(person_client src/person_client.cpp)\ntarget_link_libraries(person_client ${catkin_LIBRARIES})\nadd_dependencies(person_client ${PROJECT_NAME}_gencpp)\n```\n\n第三项是添加依赖项，因为代码涉及到动态生成，我们需要将可执行文件与动态生成的程序产生依赖关系。\n**注：这里添加的依赖项用到的是gencpp包，是一个C++用的ROS message 和 service 生成器，以依赖动态生成的cpp文件**。\n\n### 最后，编译并运行\n\n运行rosmaster，及其功能包，不再重复。\n\n可以看到运行Server后，启动Client会发一次人物信息，在Server端看到，看到后反馈给Client确认后终止这次发送行为。\n先运行Client的话则会一直等待Server端接收，直到Server端启动接收到信息\n\n\n\n## 参数的使用与编程\n\n- 至此我们学习了ROS中的两种核心通信机制：Topic（话题）模式 和 Service（服务）模式。\n\n- Topic中的Publisher、Subscriber，Service中的Client、Server，消息类型msg、srv以及它们的自定义数据类型。 \n- 这次讲讲参数的使用\n\n### 简介\n\n在ROS Master中，存在一个参数服务器（Parameter Server），它是一个全局字典，即一个全局变量的存储空间，用来保存各个节点的配置参数。各个节点都可以对参数进行全局访问。\n\n### 创建pkg\n\n```\ncd ~/Ros_WorkSpace/src\ncatkin_create_pkg learning_parameter roscpp rospy std_srvs\n```\n\n### rosparam使用\n\n在ROS中，参数文件常以YAML文件的格式保存\n\n![image-20250922194609158](./ROS基础/image-20250922194609158.png)\n\n打开海龟节点后使用list命令看一下：\n\n![image-20250922194738800](./ROS基础/image-20250922194738800.png)\n\n可以使用get命令获取某个参数值\n\neg：\n\n```\nrosparam get /turtlesim/background_b \n```\n\n![image-20250922194923502](./ROS基础/image-20250922194923502.png)\n\n也可以更改这些参数，使用set命令，随后使用get查看到已经更改。\n\n![image-20250922195108210](./ROS基础/image-20250922195108210.png)\n\n但是，实际海龟背景尚未改变，发送一个clear的空内容服务请求。\n\n![image-20250922195238238](./ROS基础/image-20250922195238238.png)\n\n这样子命令行更改有点麻烦，可以导出参数文件，更改后再load回去。\n\n```powershell\nrosparam dump param.yaml\n//导出参数，并保存为param.yaml文件\n```\n\n![image-20250922195757467](./ROS基础/image-20250922195757467.png)\n\n打开后，更改参数然后保存。\n\n![image-20250922195829768](./ROS基础/image-20250922195829768.png)\n\n```powershell\nrosparam load param.yaml\n```\n\n随后，导入参数，再clear一下，可以看到颜色更改了。\n\n![image-20250922200000961](./ROS基础/image-20250922200000961.png)\n\n其他的命令自己可以尝试。\n\n### 利用程序来使用参数\n\n程序如下\n\n```c++\nint main(int argc, char **argv)\n{\n\tint red, green, blue;\n\n    // ROS节点初始化\n    ros::init(argc, argv, \"parameter_config\");\n\n    // 创建节点句柄\n    ros::NodeHandle node;\n\n    // 读取背景颜色参数\n\tros::param::get(\"/turtlesim/background_r\", red);\n\tros::param::get(\"/turtlesim/background_g\", green);\n\tros::param::get(\"/turtlesim/background_b\", blue);\n\n\tROS_INFO(\"Get Backgroud Color[%d, %d, %d]\", red, green, blue);\n\n\t// 设置背景颜色参数\n\tros::param::set(\"/turtlesim/background_r\", 255);\n\tros::param::set(\"/turtlesim/background_g\", 255);\n\tros::param::set(\"/turtlesim/background_b\", 255);\n\n\tROS_INFO(\"Set Backgroud Color[255, 255, 255]\");\n\n    // 读取背景颜色参数\n\tros::param::get(\"/turtlesim/background_r\", red);\n\tros::param::get(\"/turtlesim/background_g\", green);\n\tros::param::get(\"/turtlesim/background_b\", blue);\n\n\tROS_INFO(\"Re-get Backgroud Color[%d, %d, %d]\", red, green, blue);\n\n\t// 调用服务，刷新背景颜色\n\tros::service::waitForService(\"/clear\");\n\tros::ServiceClient clear_background = node.serviceClient<std_srvs::Empty>(\"/clear\");\n\tstd_srvs::Empty srv;\n\tclear_background.call(srv);\n\t\n\tsleep(1);\n\n    return 0;\n}\n```\n\n添加cmake编译选项，不再重复。\n\n运行后，更改了。\n\n![image-20250922205135270](./ROS基础/image-20250922205135270.png)\n\n## launch文件的使用\n\n上文中，启动一个ros节点需要使用rosrun命令，每次启动都有打开一个新的终端，十分麻烦。\n\n通过编写launch文件，将多个节点的内容写入进去，就可以一次性开启多个节点。\n\n- launch文件可以放在任意一个软件包的目录下\n- 启动launch文件时自动运行roscore，启动rosmaseter。\n- 必须按照launch文件内容的格式进行编写，/为结尾。\n\n```c++\n<launch>\n\t\t//节点1\n        <node pkg=\"learning_service\" type=\"turtle_spawn\" name=\"turtle_spawn\" />\n    \t//节点2\n        <node pkg=\"turtlesim\" type=\"turtlesim_node\" name=\"turtlesim_node\"/>\n\n</launch>\n```\n\n在launch文件中，为一个节点添加 **launch-prefix=\"gnome-terminal-e\"**属性，可以让节点单独运行在一个独立终端中。\n\n```c++\n<node pkg=\"learning_service\" type=\"turtle_spawn\" name=\"turtle_spawn\" launch-prefix=\"gnome-terminal-e\"/>\n```\n\n\n\n## Ros机器人运动控制\n\n在上面的基本实验中，我们掌握了基本的话题消息订阅发布、客户端服务端服务发送。\n\n现在，可以添加机器人仿真环境，利用ros来实验控制机器人运行了。\n\n### 安装机器人仿真环境\n\n打开src目录，下载仿真环境pkg\n\n```\ngit clone https://github.com/6-robot/wpr_simulation.git\n```\n\n运行包内的安装程序\n\n```\ncd Ros_WorkSpace/wpr_simulation/scrips\n./install_for_noetic.sh\n```\n\n安装完成后，回到workspace编译（source和编译再后文中默认进行）\n\n```\nroslaunch wpr_simulation wpb_simple.launch\n```\n\n可以看到一个仿真界面\n\n### 创建pkg，编写程序实现基本的运动控制\n\n创建vel_pkg并添加roscpp rospy geometry_msgs依赖\n\n添加vel_node函数，内容如下：\n\n```c++\nint main(int argc, char **argv) {\n    //初始化\n    ros::init(argc, argv, \"vel_node\");\n\t//创建句柄\n    ros::NodeHandle n ;\n\t//定义发布对象vel_pub\n    ros::Publisher vel_pub = \t\n    //发布话题，类型是geo内的twist，话题名叫cmd_vel\n    n.advertise<geometry_msgs::Twist(\"/cmd_vel\", 10);\n\t//定义数据类型 \n    geometry_msgs::Twist vel_msg;\n\n    vel_msg.linear.x = 0;\n    vel_msg.linear.y = 0;\n    vel_msg.linear.z = 0;\n\n    vel_msg.angular.x = 0;\n    vel_msg.angular.y = 0;\n    vel_msg.angular.z = 0.6;\n\t\n    ros::Rate r(30);\n    //开启while循环，不断发布消息\n    while (ros::ok()) {\n        vel_pub.publish(vel_msg);\n        r.sleep();\n    }\n    return 0 ;\n}\n```\n\n在cmakelist中找到这两个选项，复制并取消注释，里面名字更改成自己的c++文件名\n\n经典操作了，以后不再赘述\n\n![image-20250923123719319](./ROS基础/image-20250923123719319.png)\n\n编译运行后，就可以看到仿真里面的机器人按照你的程序进行运动了。\n\n## 激光雷达\n\n### TOF激光雷达\n\n雷达分为激光发射和接受两个模块，通过激光的发射与接收能测定障碍物的距离，再不断旋转雷达，就能测定周围的环境。\n\n只要激光发射接收频率足够快，旋转速度足够快，就能实时得到周围环境。\n\n而在ros中Rviz，我们得到的是一个激光雷达的点阵图。\n\n![image-20250924114550648](./ROS基础/image-20250924114550648.png)\n\n### Rviz\n\n全名叫做Robot Visualization Tool ，是一个可视化工具。可以可视化传感器的数据，机器人运算处理的中间结果，比如显示路径规划，目标框选。\n\n#### 操作：\n\n- 启动仿真程序后，在终端中输入rviz。![image-20250924115406006](./ROS基础/image-20250924115406006.png)\n\n- 修改左边界面显示，左下角add RobotModel和LaserScan，如图（如果没有机器人模型的话就source一下再打开rviz）\n\n![image-20250924120357814](./ROS基础/image-20250924120357814.png)****\n\n- 这一排红色点阵就是雷达获取的数据，可以在仿真环境中添加障碍物来查看rviz的显示\n\n    ![image-20250924121504960](./ROS基础/image-20250924121504960.png)\n\n- 可以导出此次的配置文件，然后下次打开rviz后再open配置文件。点击左上角的flies目录就可以看到\n\n#### Tips\n\n- rviz只是一个数据可视化界面，用于显示机器人获取的数据，无论他是仿真机器人还是真实的机器人\n- 可以通过launch文件来自动配置rviz的参数\n- \n\n#### Ros中激光雷达的消息包格式\n\n在roswiki官网中可以打开sensor_msgs/LaserScan Message，注释翻译成中文\n\n\n\n![image-20250924121815175](./ROS基础/image-20250924121815175.png)\n\n可以在终端中显示消息类型\n\n输入rostopic echo /scan --noarr\n\n![image-20250924121950186](./ROS基础/image-20250924121950186.png)\n\n### 用c++实现获取激光雷达\n\n![image-20250924195957070](./ROS基础/image-20250924195957070.png)\n\n- 构建一个新的软件包，包名为lidar_pkg\n\n- 新建一个节点，lidar_node\n\n- 在节点中，向ros大管家nodehandle申请订阅话题，并设置回调函数为lidarcallback（）\n\n- 构建回调函数，接受并处理数据\n\n- 调用ros_info()显示雷达检测到的前方障碍物距离\n\n  ​    \n\n    函数如下：\n\n```c++\nvoid lidar_Callback(const sensor_msgs::LaserScan msg) {\n    float fMidDist = msg.ranges[180];\n    ROS_INFO(\"前方测距 ranges[180] = %f 米\",fMidDist);\n}\n\n\nint main(int argc, char **argv) {\n    setlocale(LC_ALL, \"\");\n\n    ros::init(argc, argv, \"lidar_node\");\n\n    ros::NodeHandle n ;\n\n    ros::Subscriber lidar_sub = n.subscribe(\"/scan\", 10, &lidar_Callback);\n\n    ros::spin ();\n    return 0;\n}\n    \n```\n\n编译运行后，再打开仿真工具，移动前方的书架，可以看到距离的变化\n\n![image-20250924205150384](./ROS基础/image-20250924205150384.png)\n\n![image-20250924205207354](./ROS基础/image-20250924205207354.png)\n\n## 实现简单的避障控制\n\n![image-20250924205557332](./ROS基础/image-20250924205557332.png)\n\n在上一节的基础上修改程序就可以了\n\n- 发布速度控制话题/cmd_vel\n- 构建速度控制消息包，vel_cmd用于数据传输\n- 根据激光雷达的测距值，调整机器人运动速度，避开障碍\n\n```c++\nros::Publisher vel_pub ;\nint n = 0;\nvoid lidar_Callback(const sensor_msgs::LaserScan msg) {\n    float fMidDist = msg.ranges[180];\n    ROS_INFO(\"前方测距 ranges[180] = %f 米\",fMidDist);\n\n    if (n>0) {\n        n--;\n        return;\n    }\n    geometry_msgs::Twist vel_cmd;\n    if (fMidDist < 1.5) {\n        vel_cmd.angular.z = 0.3;\n        n=50;\n    }\n    else {\n        vel_cmd.linear.x = 0.1;\n    }\n    vel_pub.publish(vel_cmd);\n  \t//如果没有速度的输入，机器人会按照最近一次的速度运动\n}\n\n\nint main(int argc, char **argv) {\n    setlocale(LC_ALL, \"\");\n\n    ros::init(argc, argv, \"lidar_node\");\n\n    ros::NodeHandle n ;\n\n    ros::Subscriber lidar_sub = n.subscribe(\"/scan\", 10, &lidar_Callback);\n\n                    vel_pub  = n.advertise<geometry_msgs::Twist>(\"/cmd_vel\", 10);\n\n    ros::spin ();\n\n    return 0;\n}\n```\n\n## Ros中IMU的使用\n\n### Imu Message\n\n![image-20250925105143048](./ROS基础/image-20250925105143048.png)\n\n- angular_veloity ——————x,y,z三轴的旋转速度\n- liner——acceleration——————xyz三轴矢量加速度\n- orientation——————xyz经处理后的偏移量，数据类型是Quaternion，包含float x，y ，z ，w。四元数描述。\n\n### C++实现imu数据获取\n\nRos官方给出了三个话题\n\n![image-20250925110052247](./ROS基础/image-20250925110052247.png)\n\n- 六轴原始数据\n\n- 六轴原始数据和融合后的四元数姿态描述\n\n- 加上磁力计的九轴数据\n\n    **Cpp实现步骤**：\n\n- 创建一个新的pkg\n\n- 建立节点，imu_node\n\n- 编程构建imu_node,利用回调函数对imu的数据进行处理\n\n- 使用tf工具转换数据，并屏幕打印\n\n```c++\nvoid IMUCallback(const sensor_msgs::Imu msg)\n{\n    // 检测消息包中四元数数据是否存在\n    if(msg.orientation_covariance[0] < 0)\n        return;\n    // 四元数转成欧拉角\n    tf::Quaternion quaternion(\n        msg.orientation.x,\n        msg.orientation.y,\n        msg.orientation.z,\n        msg.orientation.w\n    );\n    double roll, pitch, yaw;\n    tf::Matrix3x3(quaternion).getRPY(roll, pitch, yaw);\n    // 弧度换算成角度\n    roll = roll*180/M_PI;\n    pitch = pitch*180/M_PI;\n    yaw = yaw*180/M_PI;\n    ROS_INFO(\"滚转= %.0f 俯仰= %.0f 朝向= %.0f\", roll, pitch, yaw);\n}\n\nint main(int argc, char **argv)\n{\n    setlocale(LC_ALL, \"\");\n    ros::init(argc,argv, \"demo_imu_data\");\n\n    ros::NodeHandle n;\n    // 订阅 IMU 的数据话题\n    ros::Subscriber sub = n.subscribe(\"imu/data\", 100, IMUCallback);\n    ros::spin();\n\n    return 0;\n}\n```\n\n### 实现与运动控制的结合\n\n```c++\nros::Publisher vel_pub ;\n// IMU 回调函数\nvoid IMUCallback(const sensor_msgs::Imu msg)\n{\n    // 检测消息包中四元数数据是否存在\n    if(msg.orientation_covariance[0] < 0)\n        return;\n    // 四元数转成欧拉角\n    tf::Quaternion quaternion(\n        msg.orientation.x,\n        msg.orientation.y,\n        msg.orientation.z,\n        msg.orientation.w\n    );\n    double roll, pitch, yaw;\n    tf::Matrix3x3(quaternion).getRPY(roll, pitch, yaw);\n    // 弧度换算成角度\n    roll = roll*180/M_PI;\n    pitch = pitch*180/M_PI;\n    yaw = yaw*180/M_PI;\n    ROS_INFO(\"滚转= %.0f 俯仰= %.0f 朝向= %.0f\", roll, pitch, yaw);\n\t\t//此处可以设计pid算法\n    double t_yaw = 90;\n    float kp ,ki ,kd ;\n    double error = t_yaw - yaw ;\n\n    geometry_msgs::Twist vel_cmd;\n    kp = 0.02 ;\n    vel_cmd.angular.z = error *kp ;\n    vel_cmd.linear.x = 0.1 ;\n    vel_pub.publish(vel_cmd);\n}\n\nint main(int argc, char **argv)\n{\n    setlocale(LC_ALL, \"\");\n    ros::init(argc,argv, \"demo_imu_data\");\n\n    ros::NodeHandle n;\n    // 订阅 IMU 的数据话题\n    ros::Subscriber sub = n.subscribe(\"imu/data\", 100, IMUCallback);\n        vel_pub = n.advertise<geometry_msgs::Twist>(\"cmd_vel\", 100);\n    ros::spin();\n\n    return 0;\n}\n\n```\n\n## 栅格地图\n\n假设地图上有两个障碍物，以俯视观察他。将地图用大小相同的方格代替，被占据的格子（哪怕只占据一点）涂上黑色，未被占据的栅格涂上白色。如图\n\n![image-20250925193257940](./ROS基础/image-20250925193257940.png)\n\n**切换栅格的大小可以让障碍物的表示更加精准，理论上可以无限逼近实际的大小**。\n\n![image-20250925193415756](./ROS基础/image-20250925193415756.png)\n\n- 一个小正方形的边长（栅格边长）即为**地图分辨率**。\n- 将黑色格子标记为1，空白格子为0，这样整个地图就可以以数组的形式存储数据来表示。\n\n### Ros栅格地图消息的数据结构\n\n![image-20250925193836624](./ROS基础/image-20250925193836624.png)\n\ninfo的包含如下：\n\n![image-20250925194150699](./ROS基础/image-20250925194150699.png)\n\n\n\n### C++编写节点\n\n![image-20250925194447759](./ROS基础/image-20250925194447759.png)\n\n```c++\nint main(int argc, char **argv) {\n    ros::init(argc,argv,\"map_pub_node\");\n    ros::NodeHandle n ;\n    ros::Publisher pub = n.advertise<nav_msgs::OccupancyGrid>(\"/map\",10);\n\n    ros::Rate r(1) ;\n    while (ros::ok) {\n      \t//定义数据类型\n        nav_msgs::OccupancyGrid msg ;\n      \t//设置地图参数\n        msg.header.frame_id = \"map\";\n        msg.header.stamp = ros::Time::now();\n\n        msg.info.origin.position.x = 0;\n        msg.info.origin.position.y = 0;\n\n        msg.info.resolution = 1.0;\n        msg.info.width = 4;\n        msg.info.height = 2;\n\n        msg.data.resize(8);//将八个格子的值清0\n\t\t\t\t//给地图赋值\n        msg.data[0] = 100;\n        msg.data[1] = 100;\n        msg.data[2] = 0;\n        msg.data[3] = -1;\n\t\t\t\t\n        pub.publish(msg);\n        r.sleep();\n\n    }\n    return 0 ;\n}\n```\n\n启动roscore，启动节点，启动rviz\n\n添加起始点（Axes）和Map，topic选择写好的/map话题。可以看到地图按照我们定义的样子展现出来。\n\n![image-20250925201732674](./ROS基础/image-20250925201732674.png)\n\n```\nmsg.info.origin.position.x = 2.0;\nmsg.info.origin.position.y = 1.0;\n```\n\n如果更改了上面的数值，他们不再为0，就会出现这样子的情况：\n\n![image-20250925202124104](./ROS基础/image-20250925202124104.png)\n\n## SLAM\n\n全程是simultaneous localization and mapping，同时定位与地图创建。\n\n**定位**：是指机器人确定自己的位置。\n\n### Slam的原理\n\n如何创建地图呢？？\n\n先选定一个原点作为参照系，建立坐标轴，通过记录当前观测点与对应参照物的坐标，改变不同观测点，将多次记录的坐标进行比对，将参照物重合构建出一张完整的地图。\n\n**在Ros中如何实现建图的功能呢**\n\n首先，Ros是地图是栅格地图，机器人放置在环境中，没有开启传感器感知周围时，所有格子的值均为-1，涂上灰色。\n\n假设此时机器人开启了雷达扫描功能，激光发射出去穿过的格子都标记为0，涂上白色，代表没有障碍物。直到激光撞到障碍物，反射回来，这个格子标记为100，涂上黑色。这样子就能得到当前观测点的周围障碍物情况，改变观测点后，又进行一次扫描，标记出周围的情况。将两次的标记情况进行特征重合，构建出局部的地图。不断重复这个过程，就可以得到一副完整的地图了。\n\n![image-20250926185458750](./ROS基础/image-20250926185458750.png)\n\n### Ros中通过c++实现Slam\n\n![image-20250926185810196](./ROS基础/image-20250926185810196.png)\n\n激光雷达发送数据到slam节点进行处理（建图算法），在发布map话题让rviz可视化界面订阅，就可以显示地图出来了。\n\nSlam算法节点在ros中有提供，叫做Hector_Mapping节点。不用重复造轮子。\n\n![image-20250926200118226](./ROS基础/image-20250926200118226.png)\n\n通过运行前三条指令可以开启slam的扫描功能，在rviz界面中add选项添加机器人model和map地图\n\n![image-20250926201134977](./ROS基础/image-20250926201134977.png)\n\n第四行指令可以开启一个图像化界面来控制机器人运动\n\n![image-20250926201231220](./ROS基础/image-20250926201231220.png)\n\n控制机器人移动，建模成功。\n\n![image-20250926201452881](./ROS基础/image-20250926201452881.png)\n\n### launch文件使用\n\n操作这么多有点麻烦，现在编写一个launch文件来一次性开启这些程序。\n\n![image-20250926204242519](./ROS基础/image-20250926204242519.png)\n\n第一条语法是包含另一个launch文件的写法，￥（)用于查找括号下软件包的目录，后面接着具体文件路径。\n\n其余三条，之前已经说明过。\n\n编译运行。成功。\n\n在rviz中导出配置好的rviz，放入pkg文件夹里的rviz目录下，并命名slam.rviz。\n\n```\nrviz -d ~/Ros_WorkSpace/src/slam_pkg/rviz/slam.rviz\n```\n\n可以在终端输入这段代码打开rviz后自动加载配置文件，也可以打开rviz后再手动选择加载。\n\n![image-20250926205145607](./ROS基础/image-20250926205145607.png)\n\n可以在launch中添加参数args ，通过rviz来自动加载rviz的配置。\n\n![image-20250926205323599](./ROS基础/image-20250926205323599.png)\n\n这样子就算自动配置好launch文件了。\n","tags":["ROS"],"categories":["学习","ROS"]}]