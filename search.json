[{"title":"ROS-raspi","url":"/year/11/03/ROS-raspi/","content":"树莓派ROS小车安装树莓派相关ROS环境安装ubuntu mate系统下载ubuntu mate20.04镜像\n百度搜索ubuntu mate，进入download界面，拉倒最底下\n\n选择Browse archive and previous device ports https://releases.ubuntu-mate.org/\n\n\n\n\n\n随后进入20.04 arm64 ，下载https://releases.ubuntu-mate.org/20.04/arm64/ubuntu-mate-20.04.1-desktop-arm64+raspi.img.xz\n\n\n制作并烧录到SD卡里\n前往树莓派官网下载他的烧录工具\n\n\n\n第一个选择烧录的设备型号（树莓派4B），第二个选择自己下载的ubuntu mate ，第三个选择烧录的位置，选择你的sd卡。随后点击烧录即可\n  \n\n可以提前配置一下用户名、网络啥的。\n\n\n进入树莓派ubuntu mate系统把sd卡插入树莓派，随后插电开机。使用micro HDMI线连上显示器。\n进行基本的配置，设置用户名密码、网络连接。\n更换清华源，不再赘述。\n安装network工具\nsudo apt install net-tools\n\n查看树莓派的ip\nifconfig\n\n\n将树莓派和主机放在同一局域网，测试ping通，在主机终端输入\nping 10.43.234.55(树莓派ip)\n\n\n这样就是ping通了，可以使用远程连接。\n树莓派配置远程连接ssh连接直接终端连接：\n在ubuntu主机里，下载remmina连接工具。\nping通了之后，终端可以直接连，但是使用remmina工具更方便。\n终端输入ssh &lt;树莓派用户名&gt;@&lt;树莓派IP地址&gt;\nshh pi@10.43.234.55\n\n\n输入树莓派密码后就可以连接上了。\n利于remmina：\n这是linux下一个软件能储存信息，方便连接：\n点击左上角加好，再输入ip 密码啥的就可以连接了。\n\n利用TigerVNC进行远程桌面连接先给ubuntu mate换个桌面，自带的mate桌面有点卡。\n更换xfce4桌面并卸载自带mate桌面不赘述了（自行搜索）。\n\n个人IP校园网环境下：\n​\tPC有线连接校园网IP：10.43.173.38\n​\t树莓派无线连接宿舍校园网IP：10.43.234.55\n609wifi环境下:\n​\tPC有线连接校园网IP：10.43.173.38\n​\t树莓派无线连接宿舍校园网IP：10.43.234.55\nsync同步文件的使用基本用法:\n\n路径在左边：意味着将左边同步到右边\n路径在右边：同理\n\nsync &lt;本地路径&gt; &lt;远程连接用户名&gt;@&lt;IP地址&gt;:&lt;远程路径&gt;# 注意空格，路径写全不要用~\n\nsync同步命令是一次性的，每次输入都很长，很麻烦，编写一个脚本来实现：\n# 树莓派目标目录REMOTE_DIR=/home/pi/pi_ws/srcecho &quot;===============================&quot;echo &quot;  选择要同步的树莓派&quot;echo &quot;===============================&quot;# 显示菜单index=1for name in &quot;$&#123;!PI_HOSTS[@]&#125;&quot;; do    echo &quot;$index. $name  ($&#123;PI_HOSTS[$name]&#125;)&quot;    names[$index]=$name    ((index++))done# 用户输入编号read -p &quot;请输入编号 (1-$((index-1))): &quot; choiceif [[ -z &quot;$&#123;names[$choice]&#125;&quot; ]]; then    echo &quot;无效的编号，退出。&quot;    exit 1fi# 获取选择的名称和IPSELECTED_NAME=$&#123;names[$choice]&#125;PI_HOST=$&#123;PI_HOSTS[$SELECTED_NAME]&#125;echo &quot;&quot;echo &quot;\t\t已选择: $SELECTED_NAME ($PI_HOST)&quot;echo &quot;    本地目录:  $LOCAL_DIR/&quot;echo &quot;    目标目录:  $PI_USER@$PI_HOST:$REMOTE_DIR/&quot;echo &quot;&quot;# 二次确认read -p &quot;确认执行同步吗？(y/n): &quot; confirmif [[ &quot;$confirm&quot; != &quot;y&quot; &amp;&amp; &quot;$confirm&quot; != &quot;Y&quot; ]]; then    echo &quot;已取消同步。&quot;    exit 0fi# 检查设备是否在线ping -c 1 -W 1 &quot;$PI_HOST&quot; &amp;&gt;/dev/nullif [[ $? -ne 0 ]]; then    echo &quot;无法连接到 $PI_HOST，请检查网络。&quot;    exit 1fi# Rsync 同步rsync -avz --progress &quot;$&#123;LOCAL_DIR&#125;/&quot; &quot;$&#123;PI_USER&#125;@$&#123;PI_HOST&#125;:$&#123;REMOTE_DIR&#125;/&quot;echo &quot;同步到 $SELECTED_NAME 完成&quot;# --progress 命令可以中显示文件传输进度条，包括文件大小、已经传输的大小、传输速度和剩余时间\n\n\n-a———&gt;保留文件属性并递归复制目录\n-v———&gt;显示详细信息\n-z———&gt;压缩数据，加快传输\n–progress———&gt;显示每个文件传输进度\n\nROS与STM32间的通信完成hello world!首先，让STM32F407串口发送一个**”hello world!”**\nlinux下串口工具可以使用xTools：\n\ncutecom在我的环境下有显示的问题，不使用。\n查询串口：\nls /dev/tty*\n\n\n可以通过插拔来查找usb串口通道\nlinux系统下串口无法使用问题：\n\n没有安装usb转ttl的驱动导致问题\n没有给予usb权限\n\n解决方法：\n\n去下载对应芯片的驱动（ch340&#x2F;ch9102）,linux自带了cp210x的驱动\n使用chmod给对应串口通道施加权限，没有权限无法运行。\n\nchmod 777 &lt;设备通道&gt;eg:chmod 777 /dev/ttyUSB0\n\nros串口发布节点：\n#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &quot;serial/serial.h&quot;serial::Serial ser;void serial_init() &#123;    ser.setPort(&quot;/dev/ttyUSB0&quot;);//串口名称    ser.setBaudrate(115200);//波特率    serial::Timeout to = \t\t\t\t  \t\t\t\t\tserial::Timeout::simpleTimeout(100);//等待时间    ser.setTimeout(to);    try &#123;        ser.open();//打开串口    &#125;    catch(serial::IOException&amp; e)&#123;        ROS_ERROR_STREAM(&quot;Unable to open port.&quot;);    &#125;    if (ser.isOpen()) &#123;        ROS_INFO(&quot;/dev/ttyCH341USB0 is open&quot;);    &#125;    else &#123;        ROS_ERROR(&quot;/dev/ttyCH341USB0 open failed.&quot;);    &#125;&#125;int main(int argc, char **argv) &#123;    //ROS初始化    ros::init(argc, argv, &quot;stm32_Serial_test01&quot;);    ros::NodeHandle nh;    //创建ROS发布者节点    ros::Publisher stm32_pub = nh.advertise&lt;std_msgs::String&gt;(&quot;stm32_data&quot;, 10);    //串口相关配置    serial_init();    ros::Rate loop_rate(10);//设置循环速率    while(ros::ok())    &#123;        //获取缓冲区内的字节数        size_t n = ser.available();        if (n != 0)        &#123;            //定义一个缓冲区，将数据存放在此            uint8_t buffer[1024];            n = ser.read(buffer, n);            std::string received_data(buffer, buffer + n);  // 将字节转成字符串            ROS_INFO_STREAM(&quot;Received data: &quot; &lt;&lt; received_data);            //将接受到的内容封装为ROS消息，并发布消息出去            std_msgs::String msg;            msg.data = received_data;            stm32_pub.publish(msg);            if (received_data.find(&quot;hello world!&quot;) != std::string::npos) &#123;                ROS_INFO(&quot;STM32 sent: hello world!&quot;);            &#125;        &#125;        ros::spinOnce();        loop_rate.sleep();    &#125;    ser.close();    return 0;&#125;\n\n设置stm32串口发送到上位机后，开启此节点，可以看到成功接收。\n编写键盘输入节点实现键盘控制小车移动键盘输入节点核心是如何读取键盘输入，然后转换成数据发送话题出去\n// ----------- 函数功能：从终端读取单个按键，不需要按回车 ----------- //int getch() &#123;    struct termios oldt, newt;    int ch;    // 获取当前终端属性    tcgetattr(STDIN_FILENO, &amp;oldt);    newt = oldt;    // 关闭规范模式(ICANON)和回显(ECHO)，实现即时单字符读取    newt.c_lflag &amp;= ~(ICANON | ECHO);    tcsetattr(STDIN_FILENO, TCSANOW, &amp;newt);    // 读取单个字符    ch = getchar();    // 恢复终端原设置    tcsetattr(STDIN_FILENO, TCSANOW, &amp;oldt);    return ch;&#125;int main(int argc, char** argv) &#123;    // 初始化 ROS 节点，节点名为 keyboard_ctrl_pub    ros::init(argc, argv, &quot;keyboard_control&quot;);    ros::NodeHandle nh;    // 创建 Publisher，发布主题为 /cmd_vel，消息类型为 geometry_msgs::Twist    ros::Publisher cmd_pub = nh.advertise&lt;geometry_msgs::Twist&gt;(&quot;cmd_vel&quot;, 10);    geometry_msgs::Twist cmd;  // 创建 Twist 消息对象    std::cout &lt;&lt; &quot;\\n=== 键盘控制说明 ===\\n&quot;;    std::cout &lt;&lt; &quot;w: 前进 | s: 后退 | a: 左转 | d: 右转\\n&quot;;    std::cout &lt;&lt; &quot;空格: 停止 | q: 退出程序\\n&quot;;    std::cout &lt;&lt; &quot;====================\\n&quot;;    // 主循环：持续读取键盘按键    while (ros::ok()) &#123;        int c = getch();  // 获取键盘输入        // 每次先清零速度        cmd.linear.x = 0.0;        cmd.angular.z = 0.0;        // 按键控制逻辑        if (c == &#x27;w&#x27;) &#123;            cmd.linear.x = 0.5;     // 前进，线速度为 0.5 m/s        &#125; else if (c == &#x27;s&#x27;) &#123;            cmd.linear.x = -0.5;    // 后退        &#125; else if (c == &#x27;a&#x27;) &#123;            cmd.angular.z = 1.0;    // 左转，角速度正方向        &#125; else if (c == &#x27;d&#x27;) &#123;            cmd.angular.z = -1.0;   // 右转，角速度负方向        &#125; else if (c == &#x27; &#x27;) &#123;            cmd.linear.x = 0;       // 停止            cmd.angular.z = 0;        &#125; else if (c == &#x27;q&#x27;) &#123;            // 按 q 退出程序            std::cout &lt;&lt; &quot;退出程序\\n&quot;;            break;        &#125;        // 发布速度命令        cmd_pub.publish(cmd);        // 打印调试信息        ROS_INFO(&quot;发布速度: linear=%.2f m/s, angular=%.2f rad/s&quot;, cmd.linear.x, cmd.angular.z);    &#125;    return 0;&#125;\n\n编写了这个控制节点后，成功将数据利用话题的方式发布出去。\n通信节点前面写了键盘并且把\n","categories":["学习","ROS"],"tags":["ROS","raspi"]},{"title":"11月的碎碎念","url":"/year/11/08/11%E6%9C%88%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/","content":"11月初10月底，奖学金到账了，心情变好了一点。\n10月底到11月真的好多事情，线代考试、机原考试、dx那边还有作业要写、实验室那边还有点任务，课内的东西真的不想学啊，感觉全没啥用。。。等下周忙完了回一趟家，再去看个鬼灭电影，好久没看电影了难得感兴趣一次。\nTMD的，给兄弟找到女朋友了，不过也正常，那女生追了一年多，难道终于成了吗？要我说他TM纯傻逼，这么明显不可能看不出来，那女的就差a到他脸上了，谁知道哥们怎么想的。\n目前，整体感觉还不错，减肥也在进行,也在学新的知识，跑步是真的爽啊，强烈推荐心情不稳定的人去跑跑步。跑完5km后的微风拂在汗水上，卷走身心的疲惫，回去再洗个不冷不热的澡，日子还是挺舒服的嘛。\n关于女朋友，顺其自然吧（虽然这话就等于没有）。现在先努力提升自己，减肥跑步学习。\n还有，现在文笔是真的垃圾，感觉语言太干了。\n","categories":["碎碎念"],"tags":["碎碎念"]},{"title":"从零开始一个机械臂","url":"/year/11/13/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA%E6%9C%BA%E6%A2%B0%E8%87%82/","content":"从零开始一个机械臂学习路线规划\nlinux基础、ROS基础、ROS通信\n\n机械臂仿真：\n\nurdf文件\ngazebo仿真的搭建\nxacro插件\n\n\nros_control基础控制\n\n机械臂运动学解算\n\nmoveit框架\n\n上下层整合通信\n\n\n","categories":["学习","ROS"],"tags":["ROS、机械臂"]},{"title":"关于电赛","url":"/year/11/08/%E5%85%B3%E4%BA%8E%E7%94%B5%E8%B5%9B/","content":"25年电赛E题回顾与总结电赛历程回顾前期备赛7.15-7.29从7.15开始，先后购买了灰度传感器、小车车模、k210视觉识别模块、180°+270°二维云台，画了两版MSP拓展板，完美完成24年H题，学习使用了git工具合并代码，上述模块的驱动开发，逐飞MSP库的使用。23年题目没来得及搞定。\n电赛中7.30日7:30-8.2日20:00第一天早上，一早过去开题，随后就讨论了方案的选择，基本定下了基础部分的逻辑和个人的分工。对于270度舵机是否需要更换的情况进行讨论，最后决定更换成360度舵机，还重新定制了一版亚克力板子。\n下午，直接开始写小车循迹代码和视觉识别代码，硬件在搞激光笔的移植更改，一开始搞好了，几个小时后原来的激光笔烧了，重新买了一个。\n晚上，硬件队友测试舵机时用电脑USB直接驱动舵机，把电脑烧了。-1000块。此时，小车循迹逻辑已经搞定，用小型车模在不装载云台的情况下调通PID，成功完成任务一。视觉识别部分也完成了，但是由于k210硬件限制，帧数很低，当时还没有意识到问题的严重性。\n第一天没熬夜，好多材料没到，于是11点回去睡觉。\n第二天早上7：30到位了，硬件队友去修电脑了，测试舵机逻辑，讨论并继续写后续任务逻辑。搞k210与云台的驱动时，出现了严重的问题，k210帧率识别太低，原来的方案：“旋转一圈直到识别矩形后云台停下”放弃，改成“旋转一定角度后停下来等待响应识别”。\n下午，亚克力板到位，360°舵机到位，硬件按要求焊接第二个开关模块，飞线连接各个模块并将开发板与云台装车，车辆大体结构装好，激光笔就为，各个硬件要求达到。软件接着写逻辑，目前为止还算顺利。\n傍晚，突然间天猛星工作时发热很严重，一通测试后发现是其中一部分被击穿了，导致开发板持续发热升温，很绝望当时已经没有别的好的开发板了，最后决定赌一把，把一块核心有问题但是其他部分没问题的元件拆下来放到那块其他部分元件出问题的上面，硬件队友很给力，还是救回来了。给我们吓出一身汗。\n修好后，根据新车结构调了一版PID，使小车完成任务一。\n凌晨到第三天早上五点，熬夜测试云台的旋转角度多少合适，测试k210识别的最短时间为多少，测试了一晚上，大致测试出了时间，但是还是很难推进任务。五点睡觉。\n第三天早上八点起来，一早上接着实验测试云台旋转的时间与停下的时间，很折磨要么就是识别成功但是超时打靶，要么就是识别不到，k210帧率又上不去了，这时候很绝望差点就弃赛了。\n中午，我找人借了一块OPENMV，一通测试后帧率能有40帧，又好起来了！感觉有希望继续做下去。立马动工修改了方案，又改成了最初的方案“以一定速度旋转一圈，识别到后停下”。硬件队友更改优化了小车的结构，让摄像头和激光笔的物理距离拉近了，减少了软件的工作。\n下午，突然间，OPENMV变砖了，拯救了一个小时都没搞好，这个时候真想哭了，好不容易看到点希望又破灭了。突然，想到了k210送的SD卡，把程序放到SD卡后插入OPENMV后，成功了，又有希望了。\n晚上，一个继续搞云台控制，一个搞OPENMV视觉。吃完饭回来后突然，程序出BUG了，舵机不转，一通查BUG，查了一晚上，最后发现PWM初始化的时候多打了个0。\n凌晨到五点，更改方案让OPENMV计算PID结果再串口通信给MSP调控占空比。两个人一起联调云台控制，修改参数，搞到五点睡觉。\n最后一天早上八点多起床，人已经很晕了，接着搞云台控制，总是会出一些bug，然后找找半天很浪费时间还是没休息好，人太晕了。\n中午，跑了一下第一问，突然间又有问题了，总是会跑出线然后转弯次数加一了，当时没想出来原因，现在回头看了一下估计是环境光线和电池电量，电压不一样会导致写死的转速不太一样，环境光导致灰度有时候会读取错误，这个问题待解决，要尽量排除这些外部因素影响。\n接着搞云台控制，发现OPENMV在复杂环境下的识别有问题，有概率识别不到，并且距离远了识别不到矩形框，赶紧想办法解决，没有什么很好的思路。\n傍晚，快封箱了，改了一版新的视觉，复杂环境下的识别有了保障，但是距离远了还是难以解决，硬件限制死了，最后第三问只能看运气了，距离只要不是最远处都可以识别。\n临近结束，最后跑第一问，又出现大问题，转弯会跑飞，最后10min赶紧修复，踩点修好，吓出一身冷汗。\n最后，成功封箱，收拾东西，休息。\n最后拿去测评,第一问出现循迹计数不准,少跑一段路程和在拐角处跑飞出去的问题.\n电赛经验总结不要用电脑USB直接高压供电给模块，如舵机电机这种需要5V驱动的，会烧！！！！不要用电脑USB直接高压供电给模块，如舵机电机这种需要5V驱动的，会烧！！！！不要用电脑USB直接高压供电给模块，如舵机电机这种需要5V驱动的，会烧！！！！购买学习模块的时候，能上最好的就上最好的，贵有他的道理，不亏的。这次因为设备硬件问题吃了大亏。视觉舵机尽量上好的，不然软件写到死也搞不定的。学习准备模块的时候，要封装好驱动代码，保证代码简洁高效可用，方便比赛的时候调用准备的时候效率高一点，把一些常见控制（舵机、电机）全部学会封装好代码硬件设计电路板时考虑全面，做到真正的通用拓展，可以随赛题要求更改。学习亚克力板等结构的改装，能自己打孔设计备好常用的固定用具，螺丝螺母、铜柱、电工胶布、螺丝刀等，四处找零件太难受了。出材料清单后，第一时间购买相关用品，每一个都要备用两个以上，开发板备用三个。不要嫌贵就拖，越拖越贵。想办法尽量解决环境干扰问题，电池电压影响的电机转速问题，环境光影响的视觉与灰度问题软件写好了就要保存，注释记得顺手写，不然","categories":["学习","电赛"],"tags":["电赛"]},{"title":"ROS基础","url":"/year/11/03/ROS%E5%9F%BA%E7%A1%80/","content":"ROS前言使用的ros版本为Noetic版本，基于Ubuntu20.04.6\nros是什么\nROS：Robot Operating System\n包括了四个part：通信机制、开发工具、应用功能、生态系统\n这种模式旨在提高机器人研发中的软件复用率\n\n节点(Node) 与 节点管理器(Node Master)\n2.通信模式之一——Topic模式\n\nMessage：定义数据的类型，具有一定的数据结构定义\n单向的，可多次\n数据的管道称为Topic（话题）\n使用 发布&amp;订阅 模型，右下图显示了Camera Node是发布者，图像处理节点和图像显示节点是订阅者。\n话题的消息的接口使用 .msg 文件定义\n\n通信模式之二——Service模式\n\nC&#x2F;S模型\n带有反馈的机制\n双向的，来往一次\n如左下图，图像处理节点向Camera节点发出请求（比如上调图像分辨率），Camera节点上调分辨率后向图像处理节点发出反馈。\n服务的数据内容可用 .srv 自定义\n\n两者对比\n参数(Parameter)\n\n参数是一个“字典”\n存储在ROS Master服务器，节点可以对参数存储、检索、更新（如图）\n适合静态存储、非二进制\n\n文件系统\n\n文件系统代表了代码的结构\n\nROS命令行工具回顾第一个小海龟程序打开小海龟程序： 终端，启动ROS Master：\nroscore\n\n终端2，启动小海龟仿真器： （输入rosrun turtlesim，敲两下Tab健可查看该命令下有哪些功能）\nrosrun turtlesim turtlesim_node\n\n终端3，启动海龟控制节点：\nrosrun turtlesim turtle_teleop_key\n\n\n查看系统中的计算图：rqt_graph新建终端窗口：\nrqt_graph\n\n可展示系统中运行的计算图： 可以清晰地了解系统节点间通信的部分信息。 teleop_turtle节点（键盘控制节点）通过cmd_vel（topic）向turtlesim节点（海归仿真器节点）发出消息，使得小海龟移动。\nrosnode显示节点列表：rosnode list可以看到有3个节点。\n查看节点信息：rosnode info查看节点的具体信息：rosnode info /节点名 我们查看海龟仿真器节点&#x2F;turtlesim的信息：  可以看到海龟仿真器节点&#x2F;turtlesim自己有一些发布和订阅，也有一些服务。\nrostopic显示topic列表：rostopic list\n手动发布数据给topic我们来手动发布数据给topic来控制海龟移动，使用rostopic pub 上图我们看到小海龟是通过&#x2F;cmd_vel这个topic进行发布信息而移动的，这次我们通过手动publish数据给这个topic来控制小海龟移动。 格式：rostopic pub (参数) 话题名 消息数据结构 “具体数据” 例，我们输入：（我们可以使用Tab键让我们自动填充数据，使用方向键←→移动到指定位置修改数据，比如我们把x的0.0改成了1.0）\nrostopic pub /turtle1/cmd_vel geometry_msgs/Twist &quot;linear:  x: 1.0  y: 0.0  z: 0.0angular:  x: 0.0  y: 0.0  z: 0.0&quot;\n\n小海龟沿着正前方向移动了1单位，我们再使用参数-r 5移动5次，小海龟就撞上了南墙。 Ctrl+C就可以终止。 \nrosmsg查看消息数据结构上例我们使用了消息数据结构定义了一个消息传给topic，我们可以查看有哪些消息数据结构。 查看消息数据结构使用：rosmsg show … 在输入过程中，我们可以勤使用Tab键查看或填充内容。 我们可以看到geometry_msgs&#x2F;Twist数据结构的内容。\n使用服务通信方式：rosservice上例我们使用了向topic传msg来控制节点，这次我们试试第二种通信方式service。\n查看服务列表：rosservice list\n手动通过服务来进行操作这次我们通过人工产生服务（service）来诞生一只新海龟，使用rosservice call &#x2F;spawn … 在服务列表中，有个&#x2F;spawn服务，可以产生一只新的海龟。 格式：rosservice call (参数) 服务名 “具体数据”  这时我们再输入rostopic list，可以看到turtle2已经在topic里了。\n话题记录和复现：rosbag试想我们尝试让海龟以我们指定的路径移动了一回，我们想要把它 记录下来，拷贝到自己的实验室再复现出来，我们就可以使用话题记录功能。 常用命令：rosbag record -a -O 文件名 比如我们使用之前打开的键盘操作器让海龟移动一圈并记录下来： （1）打开新终端输入rosbag record -a -O cmd_record 这样就开始记录了： （2）移动一下： 到记录界面按Ctrl+C停止： 文件就记录在了这里： （3）接下去关闭所有打开的ros节点 重新开启roscore，开启海龟节点rosrun turtlesim turtlesim_node 这时我们输入 rosbag play cmd_record就可以复现之前的移动啦！ \n创建ros工作空间与功能包1.What is Workspace(工作空间)工作空间（Workspace）：存放工程开发相关文件的文件夹。类似一个IDE（例如Pycharm）新建一个工程，就是一个工作空间。包含4个文件夹：\n\nsrc：代码空间（Source Space）：放置功能包代码\nbuild：编译空间（Build Space）：编译过程中产生的中间文件，不用过多关注\ndevel：开发空间（Development Space）：放置编译生成的可执行文件、库、脚本\ninstall：安装空间（Install Space）：存放可执行文件，与上面有一定重复\n\n2 .创建工作空间创建:mkdir -p ~/catkin_ws/srccd ~/catkin_ws/src \t\t//进入路径catkin_init_workspace\t//创建\n\n我们先创建一个src文件夹，然后进入该文件夹第3行catkin_init_workspace意为将当前文件夹变为工作空间，使其拥有工作空间的属性\n注：“~&#x2F;”意为当前用户名目录；“-p”意为递归创建目录，即直接创建多级目录。src文件夹即代码空间，不能自行用别的名称代替\n可以看到创建了这么一个txt文件，说明创建工作空间成功。\n编译空代码的工作空间要编译工作空间，先要回到工作空间的根目录。\ncd ~/catkin_ws //catkin_make\n\n使用catkin_make为编译指令，将src里的源码进行编译\n\n可以看到生成了build和devel两个新文件夹，devel存放了编译完成的内容。 这里没有生成install文件夹，要生成install文件夹，输入catkin_make install：\n\ninstall中生成了可执行文件。\n这样一个空的工作空间创建好了，并且空的代码空间（功能包）编译完成。\n创建功能包功能包是放置ROS源码的最小单元。\n上面我们创建了一个空的工作空间，src文件夹里面没写东西，现在我们创建一个自己的功能包。\n注意同一工作空间下，不允许存在同名功能包；不同工作空间下，允许存在同名功能包。\n指令格式：catkin_create_pkg  [depend1] [depend2] [depend3]\n为包名\n[depend]为依赖，即指明编译的时候需要ROS中的其他功能包，如需要调用python、C++库，就要指明rospy、roscpp\ncd ~/catkin_ws/srccatkin_create_pkg test_pkg std_msgs rospy roscpp\n\n创建后记得编译一下。\n设置并检查环境变量编译完功能包后，为了运行，先设置环境变量，以便系统找到我们的工作空间和功能包。\nsource ~/catkin_ws/devel/setup.bash\n\n检查：\necho $ROS_PACKAGE_PATH\n\n发布者Publisher的编程实现编程publisher 发送 message 产生topic，让海龟（sub）订阅实现功能。\n进入src，创建功能包。\ncatkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim\n\n如何实现一个发布者程序：\n初始化ROS节点\n向ROS Master 注册节点信息，包括话题名和话题数据类型\n创建消息数据\n按照一定频率循环发布消息\n\n具体操作如下：\n先在src目录下创建源文件（c++&#x2F;Python）\n\n编写程序，修改cmakelist文件，回到工作空间编译并source\n\n终端运行roscore，再打开一个终端运行rosrun +功能包下的程序\n\n最终能看到小海龟按设定的程序运动\n\n\n具体程序如下：#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;int main(int argc, char **argv)&#123;\t// ROS节点初始化\tros::init(argc, argv, &quot;velocity_publisher&quot;);\t// 创建节点句柄\tros::NodeHandle n;\t// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10\tros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10);\t// 设置循环的频率\tros::Rate loop_rate(10);\tint count = 0;\twhile (ros::ok())\t&#123;\t    // 初始化geometry_msgs::Twist类型的消息\t\tgeometry_msgs::Twist vel_msg;\t\tvel_msg.linear.x = 0.5;\t\tvel_msg.angular.z = 0.2;\t    // 发布消息\t\tturtle_vel_pub.publish(vel_msg);\t\tROS_INFO(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z);\t    // 按照循环频率延时\t    loop_rate.sleep();\t&#125;\treturn 0;&#125;\n\n订阅者Sub的实现\n初始化ROS节点\n订阅需要的话题\n循环等待话题消息，接收到消息后进入回调函数\n在回调函数中完成消息处理\n\n操作和上面pub一样\n程序如下#include &lt;geometry_msgs/Twist.h&gt;#include &lt;ros/init.h&gt;#include &lt;ros/node_handle.h&gt;#include &lt;ros/subscriber.h&gt;#include &lt;turtlesim/Pose.h&gt;void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg) &#123;    ROS_INFO(&quot;turtle pose : x :%0.6f, y :%0.6f&quot;,msg-&gt;x,msg-&gt;y);&#125;int main(int argc, char **argv) &#123;    //ros初始化    ros::init(argc, argv, &quot;pose_subscriber&quot;);    //创建节点的句柄    ros::NodeHandle n ;    //创建一个Subscriber，订阅名为/turtle/pose,注册回调函数poseCallback    ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;, 10 , poseCallback) ;    //循环等待回调函数    ros::spin();    return 0;&#125;\n\n此程序可以读取小海龟的位置\n将pub和sub结合起来后的效果就是，海龟沿着设定的运动，然后sub获取他的位置\n使用rqt-graph进行查看\n\n话题消息的定义和使用\nMessage 是一种自定义的数据结构，用于话题间的数据存储和传输\n\n之前两节使用了Topic模型，我们先使用了Twist类型（geometry_msgs.msg库下的Twist类）的Message作为输入指令进行发布，接着使用了Pose类型（Turtlesim.msg库下的Pose类）的Message作为订阅消息进行接收。\n​    \n  使用rosmsg show命令查看\n  \n  以上的Message消息都是预定义好的，当我们需要自定义消息该怎么做呢？\n\n\n如何操作：\n\n创建msg文件\n  进入功能包目录里，新建msg文件夹，将所有自定义msg文件放入里面\n  使用touch命令新建一个msg文件，将定义的东西放入msg中\n  touch Person.msg//P要大写\n\n  \n\n在package.xml添加功能包依赖\n  将以下两行粘贴进入文件内\n\n\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n\n\n\n\n在cmakelist中也要更改编译选项，把自定义msg文件添加到编译环境中\n  find_package( ...... message_generation)add_message_files(FILES Person.msg)generate_messages(DEPENDENCIES std_msgs)catkin_package( ...... message_runtime)\n\n  说明如下：\n\n因为在package.xml添加了功能包编译依赖，在CMakeList.txt里的find_package中也要加上对应的部分；\n\n需要将定义的Person.msg作为消息接口，针对它做编译；  需要指明编译这个消息接口需要哪些ROS已有的包；\n\n有了34这两个配置才可将定义的msg编译成不同的程序文件\n\n因为在package.xml添加了功能包执行依赖，在CMakeList.txt里的catkin_package中也要加上对应的部分\n\n\n\n最后回到工作空间进行编译\n\n\nServce模式的编程与使用\nSever端是海龟仿真器节点，Client端是等待实现的节点，产生Request的请求，发送给Sever端。Sever端接受请求后产生一只海龟，并返回Response。中间传输的数据结构为定义好的turtlesim：：Spawn。\n\n老样子，创建一个learing_servce的pkg，添加必要的依赖\n\n新建一个c++文件，放入src目录下\n\n更改cmakelist文件的编译选项，编译文件\n\n开启roscore，进行rosrun，实现功能\n程序如下  int main(int argc, char** argv)&#123;    // 初始化ROS节点\tros::init(argc, argv, &quot;turtle_spawn&quot;);    // 创建节点句柄\tros::NodeHandle node;    // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service\tros::service::waitForService(&quot;/spawn&quot;);\tros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;);    // 初始化turtlesim::Spawn的请求数据\tturtlesim::Spawn srv;\tsrv.request.x = 2.0;\tsrv.request.y = 2.0;\tsrv.request.name = &quot;turtle2&quot;;    // 请求服务调用\tROS_INFO(&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;, \t\t\t srv.request.x, srv.request.y, srv.request.name.c_str());\tadd_turtle.call(srv);\t// 显示服务调用结果\tROS_INFO(&quot;Spwan turtle successfully [name:%s]&quot;, srv.response.name.c_str());\treturn 0;&#125;;\n\n  \n\n\n启动turle_spawn后，可以看到先是等待service应答\n随后开启turtlrsim节点后，服务应答，就在对应位置添加了一个新的小海龟\n\n服务端Sever的编程实现\nServer端本身是进行模拟海龟运动的命令端，它的实现是通过给海龟发送速度（Twist）的指令，来控制海龟运动（本身通过Topic实现）。\nClient端相当于海龟运动的开关，其发布Request来控制Server端。通过自定义名为 &#x2F;turtle_command 的Service实现，中间传输消息的数据类型为std_srvs::Trigger（一种针对服务标准std_srvs下的数据定义）来通信。Trigger意为触发，通过Trigger信号来触发Server端的运动指令。Server端接收这个Trigger信号后，可控制其是否要给海龟发送Twist指令，同时给Client发送Response反馈告诉它海龟的运动状态\n\n开启rosmaster，turtlesim之后\n 接着我们使用rosservice call ...请求海龟动起来，再打开一个终端。 （输入完 &#x2F;turtle_command 后敲个空格再用Tab键可自动填充空指令内容）\nrosservice call /turtle_command &quot;&#123;&#125;&quot;\n\n就可以看到海龟动起来了\n服务数据srv的使用在第8节我们讲解了话题消息msg的定义与使用，在第8节的例子中我们曾自定义了一个消息类型“Person”以发布个人信息，Publisher发布个人信息，Subscriber接收个人信息。\n这个例子中，Publisher会不断地发信息，Subscriber不停地接数据，一开动就停不下来了，也是topic模式的缺陷。\n本节我们使用Service模式用自定义的服务数据srv来实现，我们希望Request一次才发一次信息来显示。\n创建srv文件在pkg功能包目录下创建srv文件夹，并使用touch命令生成.srv文件\n\n在文件中写入数据结构的内容\nstring nameuint8 sexuint8 ageuint8 unknown = 0uint8 male = 1uint8 female = 2---string result//与之前Person.msg不同的是，多了破折号下面这个Response结果，上面的是Request内容。//定义好srv数据接口后，就可以根据这个定义用C++或Python编译\n\n添加功能包依赖由于此srv是自定义的，最初创建的时候没有添加依赖，所以要手动修改package.xml文件添加依赖。找到文件，把下面复制进去就好了。\n&lt;build_depend&gt;message_generation&lt;/build_depend&gt;//添加编译依赖&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;//添加执行依赖\n\n添加编译选项打开CMakeLists.txt，添加编译选项，才能顺利的把srv文件编译出来。\n大致上为四条，找到对应的部分进行更改即可。\n每一部分都有注释在上方进行介绍。\nfind_package( ...... message_generation)add_service_files(FILES Person.srv)generate_messages(DEPENDENCIES std_msgs)catkin_package( ...... message_runtime)\n\n还得把自己写的cpp文件添加进去编译\nadd_executable(person_server src/person_server.cpp)target_link_libraries(person_server $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_server $&#123;PROJECT_NAME&#125;_gencpp)add_executable(person_client src/person_client.cpp)target_link_libraries(person_client $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp)\n\n第三项是添加依赖项，因为代码涉及到动态生成，我们需要将可执行文件与动态生成的程序产生依赖关系。注：这里添加的依赖项用到的是gencpp包，是一个C++用的ROS message 和 service 生成器，以依赖动态生成的cpp文件。\n最后，编译并运行运行rosmaster，及其功能包，不再重复。\n可以看到运行Server后，启动Client会发一次人物信息，在Server端看到，看到后反馈给Client确认后终止这次发送行为。先运行Client的话则会一直等待Server端接收，直到Server端启动接收到信息\n参数的使用与编程\n至此我们学习了ROS中的两种核心通信机制：Topic（话题）模式 和 Service（服务）模式。\n\nTopic中的Publisher、Subscriber，Service中的Client、Server，消息类型msg、srv以及它们的自定义数据类型。 \n\n这次讲讲参数的使用\n\n\n简介在ROS Master中，存在一个参数服务器（Parameter Server），它是一个全局字典，即一个全局变量的存储空间，用来保存各个节点的配置参数。各个节点都可以对参数进行全局访问。\n创建pkgcd ~/Ros_WorkSpace/srccatkin_create_pkg learning_parameter roscpp rospy std_srvs\n\nrosparam使用在ROS中，参数文件常以YAML文件的格式保存\n\n打开海龟节点后使用list命令看一下：\n\n可以使用get命令获取某个参数值\neg：\nrosparam get /turtlesim/background_b \n\n\n也可以更改这些参数，使用set命令，随后使用get查看到已经更改。\n\n但是，实际海龟背景尚未改变，发送一个clear的空内容服务请求。\n\n这样子命令行更改有点麻烦，可以导出参数文件，更改后再load回去。\nrosparam dump param.yaml//导出参数，并保存为param.yaml文件\n\n\n打开后，更改参数然后保存。\n\nrosparam load param.yaml\n\n随后，导入参数，再clear一下，可以看到颜色更改了。\n\n其他的命令自己可以尝试。\n利用程序来使用参数程序如下\nint main(int argc, char **argv)&#123;\tint red, green, blue;    // ROS节点初始化    ros::init(argc, argv, &quot;parameter_config&quot;);    // 创建节点句柄    ros::NodeHandle node;    // 读取背景颜色参数\tros::param::get(&quot;/turtlesim/background_r&quot;, red);\tros::param::get(&quot;/turtlesim/background_g&quot;, green);\tros::param::get(&quot;/turtlesim/background_b&quot;, blue);\tROS_INFO(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue);\t// 设置背景颜色参数\tros::param::set(&quot;/turtlesim/background_r&quot;, 255);\tros::param::set(&quot;/turtlesim/background_g&quot;, 255);\tros::param::set(&quot;/turtlesim/background_b&quot;, 255);\tROS_INFO(&quot;Set Backgroud Color[255, 255, 255]&quot;);    // 读取背景颜色参数\tros::param::get(&quot;/turtlesim/background_r&quot;, red);\tros::param::get(&quot;/turtlesim/background_g&quot;, green);\tros::param::get(&quot;/turtlesim/background_b&quot;, blue);\tROS_INFO(&quot;Re-get Backgroud Color[%d, %d, %d]&quot;, red, green, blue);\t// 调用服务，刷新背景颜色\tros::service::waitForService(&quot;/clear&quot;);\tros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(&quot;/clear&quot;);\tstd_srvs::Empty srv;\tclear_background.call(srv);\t\tsleep(1);    return 0;&#125;\n\n添加cmake编译选项，不再重复。\n运行后，更改了。\n\nlaunch文件的使用上文中，启动一个ros节点需要使用rosrun命令，每次启动都有打开一个新的终端，十分麻烦。\n通过编写launch文件，将多个节点的内容写入进去，就可以一次性开启多个节点。\n\nlaunch文件可以放在任意一个软件包的目录下\n启动launch文件时自动运行roscore，启动rosmaseter。\n必须按照launch文件内容的格式进行编写，&#x2F;为结尾。\n\n&lt;launch&gt;\t\t//节点1        &lt;node pkg=&quot;learning_service&quot; type=&quot;turtle_spawn&quot; name=&quot;turtle_spawn&quot; /&gt;    \t//节点2        &lt;node pkg=&quot;turtlesim&quot; type=&quot;turtlesim_node&quot; name=&quot;turtlesim_node&quot;/&gt;&lt;/launch&gt;\n\n在launch文件中，为一个节点添加 **launch-prefix&#x3D;”gnome-terminal-e”**属性，可以让节点单独运行在一个独立终端中。\n&lt;node pkg=&quot;learning_service&quot; type=&quot;turtle_spawn&quot; name=&quot;turtle_spawn&quot; launch-prefix=&quot;gnome-terminal-e&quot;/&gt;\n\n\n\nRos机器人运动控制在上面的基本实验中，我们掌握了基本的话题消息订阅发布、客户端服务端服务发送。\n现在，可以添加机器人仿真环境，利用ros来实验控制机器人运行了。\n安装机器人仿真环境打开src目录，下载仿真环境pkg\ngit clone https://github.com/6-robot/wpr_simulation.git\n\n运行包内的安装程序\ncd Ros_WorkSpace/wpr_simulation/scrips./install_for_noetic.sh\n\n安装完成后，回到workspace编译（source和编译再后文中默认进行）\nroslaunch wpr_simulation wpb_simple.launch\n\n可以看到一个仿真界面\n创建pkg，编写程序实现基本的运动控制创建vel_pkg并添加roscpp rospy geometry_msgs依赖\n添加vel_node函数，内容如下：\nint main(int argc, char **argv) &#123;    //初始化    ros::init(argc, argv, &quot;vel_node&quot;);\t//创建句柄    ros::NodeHandle n ;\t//定义发布对象vel_pub    ros::Publisher vel_pub = \t    //发布话题，类型是geo内的twist，话题名叫cmd_vel    n.advertise&lt;geometry_msgs::Twist(&quot;/cmd_vel&quot;, 10);\t//定义数据类型     geometry_msgs::Twist vel_msg;    vel_msg.linear.x = 0;    vel_msg.linear.y = 0;    vel_msg.linear.z = 0;    vel_msg.angular.x = 0;    vel_msg.angular.y = 0;    vel_msg.angular.z = 0.6;\t    ros::Rate r(30);    //开启while循环，不断发布消息    while (ros::ok()) &#123;        vel_pub.publish(vel_msg);        r.sleep();    &#125;    return 0 ;&#125;\n\n在cmakelist中找到这两个选项，复制并取消注释，里面名字更改成自己的c++文件名\n经典操作了，以后不再赘述\n\n编译运行后，就可以看到仿真里面的机器人按照你的程序进行运动了。\n激光雷达TOF激光雷达雷达分为激光发射和接受两个模块，通过激光的发射与接收能测定障碍物的距离，再不断旋转雷达，就能测定周围的环境。\n只要激光发射接收频率足够快，旋转速度足够快，就能实时得到周围环境。\n而在ros中Rviz，我们得到的是一个激光雷达的点阵图。\n\nRviz全名叫做Robot Visualization Tool ，是一个可视化工具。可以可视化传感器的数据，机器人运算处理的中间结果，比如显示路径规划，目标框选。\n操作：\n启动仿真程序后，在终端中输入rviz。\n\n修改左边界面显示，左下角add RobotModel和LaserScan，如图（如果没有机器人模型的话就source一下再打开rviz）\n\n\n****\n\n这一排红色点阵就是雷达获取的数据，可以在仿真环境中添加障碍物来查看rviz的显示\n  \n\n可以导出此次的配置文件，然后下次打开rviz后再open配置文件。点击左上角的flies目录就可以看到\n\n\nTips\nrviz只是一个数据可视化界面，用于显示机器人获取的数据，无论他是仿真机器人还是真实的机器人\n可以通过launch文件来自动配置rviz的参数\n\n\nRos中激光雷达的消息包格式在roswiki官网中可以打开sensor_msgs&#x2F;LaserScan Message，注释翻译成中文\n\n可以在终端中显示消息类型\n输入rostopic echo &#x2F;scan –noarr\n\n用c++实现获取激光雷达\n\n构建一个新的软件包，包名为lidar_pkg\n\n新建一个节点，lidar_node\n\n在节点中，向ros大管家nodehandle申请订阅话题，并设置回调函数为lidarcallback（）\n\n构建回调函数，接受并处理数据\n\n调用ros_info()显示雷达检测到的前方障碍物距离\n​    \n  函数如下：\n\n\nvoid lidar_Callback(const sensor_msgs::LaserScan msg) &#123;    float fMidDist = msg.ranges[180];    ROS_INFO(&quot;前方测距 ranges[180] = %f 米&quot;,fMidDist);&#125;int main(int argc, char **argv) &#123;    setlocale(LC_ALL, &quot;&quot;);    ros::init(argc, argv, &quot;lidar_node&quot;);    ros::NodeHandle n ;    ros::Subscriber lidar_sub = n.subscribe(&quot;/scan&quot;, 10, &amp;lidar_Callback);    ros::spin ();    return 0;&#125;    \n\n编译运行后，再打开仿真工具，移动前方的书架，可以看到距离的变化\n\n\n实现简单的避障控制\n在上一节的基础上修改程序就可以了\n\n发布速度控制话题&#x2F;cmd_vel\n构建速度控制消息包，vel_cmd用于数据传输\n根据激光雷达的测距值，调整机器人运动速度，避开障碍\n\nros::Publisher vel_pub ;int n = 0;void lidar_Callback(const sensor_msgs::LaserScan msg) &#123;    float fMidDist = msg.ranges[180];    ROS_INFO(&quot;前方测距 ranges[180] = %f 米&quot;,fMidDist);    if (n&gt;0) &#123;        n--;        return;    &#125;    geometry_msgs::Twist vel_cmd;    if (fMidDist &lt; 1.5) &#123;        vel_cmd.angular.z = 0.3;        n=50;    &#125;    else &#123;        vel_cmd.linear.x = 0.1;    &#125;    vel_pub.publish(vel_cmd);  \t//如果没有速度的输入，机器人会按照最近一次的速度运动&#125;int main(int argc, char **argv) &#123;    setlocale(LC_ALL, &quot;&quot;);    ros::init(argc, argv, &quot;lidar_node&quot;);    ros::NodeHandle n ;    ros::Subscriber lidar_sub = n.subscribe(&quot;/scan&quot;, 10, &amp;lidar_Callback);                    vel_pub  = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/cmd_vel&quot;, 10);    ros::spin ();    return 0;&#125;\n\nRos中IMU的使用Imu Message\n\nangular_veloity ——————x,y,z三轴的旋转速度\nliner——acceleration——————xyz三轴矢量加速度\norientation——————xyz经处理后的偏移量，数据类型是Quaternion，包含float x，y ，z ，w。四元数描述。\n\nC++实现imu数据获取Ros官方给出了三个话题\n\n\n六轴原始数据\n\n六轴原始数据和融合后的四元数姿态描述\n\n加上磁力计的九轴数据\n  Cpp实现步骤：\n\n创建一个新的pkg\n\n建立节点，imu_node\n\n编程构建imu_node,利用回调函数对imu的数据进行处理\n\n使用tf工具转换数据，并屏幕打印\n\n\nvoid IMUCallback(const sensor_msgs::Imu msg)&#123;    // 检测消息包中四元数数据是否存在    if(msg.orientation_covariance[0] &lt; 0)        return;    // 四元数转成欧拉角    tf::Quaternion quaternion(        msg.orientation.x,        msg.orientation.y,        msg.orientation.z,        msg.orientation.w    );    double roll, pitch, yaw;    tf::Matrix3x3(quaternion).getRPY(roll, pitch, yaw);    // 弧度换算成角度    roll = roll*180/M_PI;    pitch = pitch*180/M_PI;    yaw = yaw*180/M_PI;    ROS_INFO(&quot;滚转= %.0f 俯仰= %.0f 朝向= %.0f&quot;, roll, pitch, yaw);&#125;int main(int argc, char **argv)&#123;    setlocale(LC_ALL, &quot;&quot;);    ros::init(argc,argv, &quot;demo_imu_data&quot;);    ros::NodeHandle n;    // 订阅 IMU 的数据话题    ros::Subscriber sub = n.subscribe(&quot;imu/data&quot;, 100, IMUCallback);    ros::spin();    return 0;&#125;\n\n实现与运动控制的结合ros::Publisher vel_pub ;// IMU 回调函数void IMUCallback(const sensor_msgs::Imu msg)&#123;    // 检测消息包中四元数数据是否存在    if(msg.orientation_covariance[0] &lt; 0)        return;    // 四元数转成欧拉角    tf::Quaternion quaternion(        msg.orientation.x,        msg.orientation.y,        msg.orientation.z,        msg.orientation.w    );    double roll, pitch, yaw;    tf::Matrix3x3(quaternion).getRPY(roll, pitch, yaw);    // 弧度换算成角度    roll = roll*180/M_PI;    pitch = pitch*180/M_PI;    yaw = yaw*180/M_PI;    ROS_INFO(&quot;滚转= %.0f 俯仰= %.0f 朝向= %.0f&quot;, roll, pitch, yaw);\t\t//此处可以设计pid算法    double t_yaw = 90;    float kp ,ki ,kd ;    double error = t_yaw - yaw ;    geometry_msgs::Twist vel_cmd;    kp = 0.02 ;    vel_cmd.angular.z = error *kp ;    vel_cmd.linear.x = 0.1 ;    vel_pub.publish(vel_cmd);&#125;int main(int argc, char **argv)&#123;    setlocale(LC_ALL, &quot;&quot;);    ros::init(argc,argv, &quot;demo_imu_data&quot;);    ros::NodeHandle n;    // 订阅 IMU 的数据话题    ros::Subscriber sub = n.subscribe(&quot;imu/data&quot;, 100, IMUCallback);        vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;cmd_vel&quot;, 100);    ros::spin();    return 0;&#125;\n\n栅格地图假设地图上有两个障碍物，以俯视观察他。将地图用大小相同的方格代替，被占据的格子（哪怕只占据一点）涂上黑色，未被占据的栅格涂上白色。如图\n\n切换栅格的大小可以让障碍物的表示更加精准，理论上可以无限逼近实际的大小。\n\n\n一个小正方形的边长（栅格边长）即为地图分辨率。\n将黑色格子标记为1，空白格子为0，这样整个地图就可以以数组的形式存储数据来表示。\n\nRos栅格地图消息的数据结构\ninfo的包含如下：\n\nC++编写节点\nint main(int argc, char **argv) &#123;    ros::init(argc,argv,&quot;map_pub_node&quot;);    ros::NodeHandle n ;    ros::Publisher pub = n.advertise&lt;nav_msgs::OccupancyGrid&gt;(&quot;/map&quot;,10);    ros::Rate r(1) ;    while (ros::ok) &#123;      \t//定义数据类型        nav_msgs::OccupancyGrid msg ;      \t//设置地图参数        msg.header.frame_id = &quot;map&quot;;        msg.header.stamp = ros::Time::now();        msg.info.origin.position.x = 0;        msg.info.origin.position.y = 0;        msg.info.resolution = 1.0;        msg.info.width = 4;        msg.info.height = 2;        msg.data.resize(8);//将八个格子的值清0\t\t\t\t//给地图赋值        msg.data[0] = 100;        msg.data[1] = 100;        msg.data[2] = 0;        msg.data[3] = -1;\t\t\t\t        pub.publish(msg);        r.sleep();    &#125;    return 0 ;&#125;\n\n启动roscore，启动节点，启动rviz\n添加起始点（Axes）和Map，topic选择写好的&#x2F;map话题。可以看到地图按照我们定义的样子展现出来。\n\nmsg.info.origin.position.x = 2.0;msg.info.origin.position.y = 1.0;\n\n如果更改了上面的数值，他们不再为0，就会出现这样子的情况：\n\nSLAM全程是simultaneous localization and mapping，同时定位与地图创建。\n定位：是指机器人确定自己的位置。\nSlam的原理如何创建地图呢？？\n先选定一个原点作为参照系，建立坐标轴，通过记录当前观测点与对应参照物的坐标，改变不同观测点，将多次记录的坐标进行比对，将参照物重合构建出一张完整的地图。\n在Ros中如何实现建图的功能呢\n首先，Ros是地图是栅格地图，机器人放置在环境中，没有开启传感器感知周围时，所有格子的值均为-1，涂上灰色。\n假设此时机器人开启了雷达扫描功能，激光发射出去穿过的格子都标记为0，涂上白色，代表没有障碍物。直到激光撞到障碍物，反射回来，这个格子标记为100，涂上黑色。这样子就能得到当前观测点的周围障碍物情况，改变观测点后，又进行一次扫描，标记出周围的情况。将两次的标记情况进行特征重合，构建出局部的地图。不断重复这个过程，就可以得到一副完整的地图了。\n\nRos中通过c++实现Slam\n激光雷达发送数据到slam节点进行处理（建图算法），在发布map话题让rviz可视化界面订阅，就可以显示地图出来了。\nSlam算法节点在ros中有提供，叫做Hector_Mapping节点。不用重复造轮子。\n\n通过运行前三条指令可以开启slam的扫描功能，在rviz界面中add选项添加机器人model和map地图\n\n第四行指令可以开启一个图像化界面来控制机器人运动\n\n控制机器人移动，建模成功。\n\nlaunch文件使用操作这么多有点麻烦，现在编写一个launch文件来一次性开启这些程序。\n\n第一条语法是包含另一个launch文件的写法，￥（)用于查找括号下软件包的目录，后面接着具体文件路径。\n其余三条，之前已经说明过。\n编译运行。成功。\n在rviz中导出配置好的rviz，放入pkg文件夹里的rviz目录下，并命名slam.rviz。\nrviz -d ~/Ros_WorkSpace/src/slam_pkg/rviz/slam.rviz\n\n可以在终端输入这段代码打开rviz后自动加载配置文件，也可以打开rviz后再手动选择加载。\n\n可以在launch中添加参数args ，通过rviz来自动加载rviz的配置。\n\n这样子就算自动配置好launch文件了。\n","categories":["学习","ROS"],"tags":["ROS"]},{"title":"关于焦虑","url":"/year/11/08/%E5%85%B3%E4%BA%8E%E7%84%A6%E8%99%91/","content":"关于焦虑我发现，当你目前处于一种迷茫的状态时，焦虑就伴随着出来了。焦虑和迷茫总是一起来的，就像那黑白无常。\n暑假打完电赛，对我打击非常大，那时候为了逃避，自电赛后就没在学过习。然后开学后就贼焦虑，感觉自己一事无成，纯飞舞，卷那么久还是没有啥名堂。后来，又找到了目标才好一些。\n平白的焦虑是没有用的，一定要动起来，不管做什么事情，可以是运动、学习、一些爱好。别让自己陷在短视频、游戏、互联网里面，越玩越焦虑、越玩越空虚。\n多多回归现实，兄弟们\n","categories":["碎碎念"],"tags":["碎碎念"]}]