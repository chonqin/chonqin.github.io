<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ROS学习</title>
      <link href="/year/11/01/ROS/"/>
      <url>/year/11/01/ROS/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>使用的ros版本为Noetic版本，基于Ubuntu20.04.6</p><h2 id="二、ros是什么"><a href="#二、ros是什么" class="headerlink" title="二、ros是什么"></a>二、ros是什么</h2><ul><li>ROS：Robot Operating System</li><li>包括了四个part：通信机制、开发工具、应用功能、生态系统</li><li>这种模式旨在提高机器人研发中的软件复用率</li></ul><h3 id="1-节点-Node-与-节点管理器-Node-Master"><a href="#1-节点-Node-与-节点管理器-Node-Master" class="headerlink" title="1.节点(Node) 与 节点管理器(Node Master)"></a>1.节点(Node) 与 节点管理器(Node Master)</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4cf4abf66181a4b6c4d6ccd5ff8c5e9.png#pic_center" alt="img"></p><h3 id="2-通信模式之一——Topic模式"><a href="#2-通信模式之一——Topic模式" class="headerlink" title="2.通信模式之一——Topic模式"></a>2.通信模式之一——Topic模式</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b5151a88a7d50ae4b4ac6e995fbe274.png#pic_center" alt="img"></p><ul><li>Message：定义数据的类型，具有一定的数据结构定义</li><li>单向的，可多次</li><li>数据的管道称为Topic（话题）</li><li>使用 发布&amp;订阅 模型，右下图显示了Camera Node是发布者，图像处理节点和图像显示节点是订阅者。</li><li>话题的消息的接口使用 .msg 文件定义</li></ul><h3 id="3通信模式之二——Service模式"><a href="#3通信模式之二——Service模式" class="headerlink" title="3通信模式之二——Service模式"></a>3通信模式之二——Service模式</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5526214ed935d789e03d828b463f0ad4.png#pic_center" alt="在这里插入图片描述"></p><ul><li>C&#x2F;S模型</li><li>带有反馈的机制</li><li>双向的，来往一次</li><li>如左下图，图像处理节点向Camera节点发出请求（比如上调图像分辨率），Camera节点上调分辨率后向图像处理节点发出反馈。</li><li>服务的数据内容可用 .srv 自定义</li></ul><h3 id="4-两者对比"><a href="#4-两者对比" class="headerlink" title="4.两者对比"></a>4.两者对比</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5797a3624420670cdd2c0962a3a6efcb.png#pic_center" alt="img"></p><h3 id="参数-Parameter"><a href="#参数-Parameter" class="headerlink" title="参数(Parameter)"></a>参数(Parameter)</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a43896255ea289882e9ec61987f5cf2f.png#pic_center" alt="在这里插入图片描述"></p><ul><li>参数是一个“字典”</li><li>存储在ROS Master服务器，节点可以对参数存储、检索、更新（如图）</li><li>适合静态存储、非二进制</li></ul><h2 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f92abef3679ce9fee72cd879d885ff98.png#pic_center" alt="在这里插入图片描述"></p><ul><li>文件系统代表了代码的结构</li></ul><h2 id="四、ROS命令行工具"><a href="#四、ROS命令行工具" class="headerlink" title="四、ROS命令行工具"></a>四、ROS命令行工具</h2><h3 id="1-回顾第一个小海龟程序"><a href="#1-回顾第一个小海龟程序" class="headerlink" title="1.回顾第一个小海龟程序"></a>1.回顾第一个小海龟程序</h3><p>打开小海龟程序：<br> 终端，启动ROS Master：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>终端2，启动小海龟仿真器：<br> （输入<code>rosrun turtlesim</code>，敲两下<code>Tab</code>健可查看该命令下有哪些功能）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p>终端3，启动海龟控制节点：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/697323cffea407d3f72f3cdaee58a02a.png#pic_center" alt="在这里插入图片描述"></p><h3 id="2-查看系统中的计算图：rqt-graph"><a href="#2-查看系统中的计算图：rqt-graph" class="headerlink" title="2.查看系统中的计算图：rqt_graph"></a>2.查看系统中的计算图：rqt_graph</h3><p>新建终端窗口：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rqt_graph</span><br></pre></td></tr></table></figure><p>可展示系统中运行的计算图：<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/99b2537f738a69cc0a22ab5e3a82acbc.png#pic_center" alt="在这里插入图片描述">可以清晰地了解系统节点间通信的部分信息。<br> teleop_turtle节点（键盘控制节点）通过cmd_vel（<a href="https://so.csdn.net/so/search?q=topic&spm=1001.2101.3001.7020">topic</a>）向turtlesim节点（海归仿真器节点）发出消息，使得小海龟移动。</p><h3 id="3-rosnode"><a href="#3-rosnode" class="headerlink" title="3.rosnode"></a>3.rosnode</h3><h4 id="显示节点列表：rosnode-list"><a href="#显示节点列表：rosnode-list" class="headerlink" title="显示节点列表：rosnode list"></a>显示节点列表：rosnode list</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/925ad456811072eabab0b16e704def72.png#pic_center" alt="在这里插入图片描述">可以看到有3个节点。</p><h4 id="查看节点信息：rosnode-info"><a href="#查看节点信息：rosnode-info" class="headerlink" title="查看节点信息：rosnode info"></a>查看节点信息：rosnode info</h4><p>查看节点的具体信息：<code>rosnode info /节点名</code><br> 我们查看海龟仿真器节点&#x2F;turtlesim的信息：<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/6f3eb2ad18e3173f7adc066991ce6d41.png#pic_center" alt="在这里插入图片描述"><br> 可以看到海龟仿真器节点&#x2F;turtlesim自己有一些发布和订阅，也有一些服务。</p><h3 id="4-rostopic"><a href="#4-rostopic" class="headerlink" title="4.rostopic"></a>4.rostopic</h3><h4 id="显示topic列表：rostopic-list"><a href="#显示topic列表：rostopic-list" class="headerlink" title="显示topic列表：rostopic list"></a>显示topic列表：rostopic list</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ab34938183af1424055c4a3c20159ea7.png#pic_center" alt="在这里插入图片描述"></p><h4 id="手动发布数据给topic"><a href="#手动发布数据给topic" class="headerlink" title="手动发布数据给topic"></a>手动发布数据给topic</h4><p>我们来手动发布数据给topic来控制海龟移动，使用<code>rostopic pub</code><br> 上图我们看到小海龟是通过&#x2F;cmd_vel这个topic进行发布信息而移动的，这次我们通过手动publish数据给这个topic来控制小海龟移动。<br> 格式：<code>rostopic pub (参数) 话题名 消息数据结构 “具体数据”</code><br> 例，我们输入：（我们可以使用Tab键让我们自动填充数据，使用方向键←→移动到指定位置修改数据，比如我们把x的0.0改成了1.0）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub /turtle1/cmd_vel geometry_msgs/Twist <span class="string">&quot;linear:</span></span><br><span class="line"><span class="string">  x: 1.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 0.0</span></span><br><span class="line"><span class="string">angular:</span></span><br><span class="line"><span class="string">  x: 0.0</span></span><br><span class="line"><span class="string">  y: 0.0</span></span><br><span class="line"><span class="string">  z: 0.0&quot;</span></span><br></pre></td></tr></table></figure><p>小海龟沿着正前方向移动了1单位，我们再使用参数<code>-r 5</code>移动5次，小海龟就撞上了南墙。<br> Ctrl+C就可以终止。<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/000001a66bd5d198841ecc3c559f628b.png#pic_center" alt="在这里插入图片描述"></p><h3 id="5-rosmsg"><a href="#5-rosmsg" class="headerlink" title="5.rosmsg"></a>5.rosmsg</h3><h4 id="查看消息数据结构"><a href="#查看消息数据结构" class="headerlink" title="查看消息数据结构"></a>查看消息数据结构</h4><p>上例我们使用了<strong>消息数据结构</strong>定义了一个消息传给topic，我们可以查看有哪些消息数据结构。<br> 查看消息数据结构使用：rosmsg show …<br> 在输入过程中，我们可以勤使用Tab键查看或填充内容。<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/a446daca224d4bc77e761ef2692c3a45.png#pic_center" alt="在这里插入图片描述">我们可以看到geometry_msgs&#x2F;Twist数据结构的内容。</p><h3 id="6-使用服务通信方式：rosservice"><a href="#6-使用服务通信方式：rosservice" class="headerlink" title="6.使用服务通信方式：rosservice"></a>6.使用服务<a href="https://so.csdn.net/so/search?q=%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F&spm=1001.2101.3001.7020">通信方式</a>：rosservice</h3><p>上例我们使用了向topic传msg来控制节点，这次我们试试第二种通信方式service。</p><h4 id="查看服务列表：rosservice-list"><a href="#查看服务列表：rosservice-list" class="headerlink" title="查看服务列表：rosservice list"></a>查看服务列表：rosservice list</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/32719771b899013c1c6ac95849ddcdb5.png#pic_center" alt="在这里插入图片描述"></p><h4 id="手动通过服务来进行操作"><a href="#手动通过服务来进行操作" class="headerlink" title="手动通过服务来进行操作"></a>手动通过服务来进行操作</h4><p>这次我们通过人工产生服务（service）来诞生一只新海龟，使用rosservice call &#x2F;spawn …<br> 在服务列表中，有个&#x2F;spawn服务，可以产生一只新的海龟。<br> 格式：<code>rosservice call (参数) 服务名 “具体数据”</code><br> <img src="https://i-blog.csdnimg.cn/blog_migrate/db80ee57a72b73228a2a1050d5cb6ed9.png#pic_center" alt="在这里插入图片描述"><br> 这时我们再输入<code>rostopic list</code>，可以看到turtle2已经在topic里了。</p><h3 id="7-话题记录和复现：rosbag"><a href="#7-话题记录和复现：rosbag" class="headerlink" title="7.话题记录和复现：rosbag"></a>7.话题记录和复现：rosbag</h3><p>试想我们尝试让海龟以我们指定的路径移动了一回，我们想要把它 记录下来，拷贝到自己的实验室再复现出来，我们就可以使用话题记录功能。<br> 常用命令：<code>rosbag record -a -O 文件名</code><br> 比如我们使用之前打开的键盘操作器让海龟移动一圈并记录下来：<br> （1）打开新终端输入<code>rosbag record -a -O cmd_record</code><br> 这样就开始记录了：<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/8c34c3e8ba55b97fef872094a0e9967e.png#pic_center" alt="在这里插入图片描述">（2）移动一下：<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/d4a97523dd1e02ba3d9f3de572cc0ddd.png#pic_center" alt="在这里插入图片描述">到记录界面按Ctrl+C停止：<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/ab9d48b8d0bb0f1958b197bcc8102c3f.png#pic_center" alt="在这里插入图片描述">文件就记录在了这里：<img src="https://i-blog.csdnimg.cn/blog_migrate/02513d9713deb389df68bf2e412308d9.png#pic_center" alt="在这里插入图片描述"><br> （3）接下去关闭所有打开的ros节点<br> 重新开启roscore，开启海龟节点rosrun turtlesim turtlesim_node<br> 这时我们输入 <code>rosbag play cmd_record</code>就可以复现之前的移动啦！<br> <img src="https://i-blog.csdnimg.cn/blog_migrate/f2b14c6c527a5afe88585f93ceed7931.png#pic_center" alt="在这里插入图片描述"></p><h2 id="五、创建ros工作空间与功能包"><a href="#五、创建ros工作空间与功能包" class="headerlink" title="五、创建ros工作空间与功能包"></a>五、创建ros工作空间与功能包</h2><h3 id="1-What-is-Workspace-工作空间"><a href="#1-What-is-Workspace-工作空间" class="headerlink" title="1.What is Workspace(工作空间)"></a>1.What is Workspace(工作空间)</h3><p>工作空间（Workspace）：存放工程开发相关文件的文件夹。类似一个IDE（例如Pycharm）新建一个工程，就是一个工作空间。包含4个文件夹：</p><ul><li>src：代码空间（Source Space）：放置功能包代码</li><li>build：编译空间（Build Space）：编译过程中产生的中间文件，不用过多关注</li><li>devel：开发空间（Development Space）：放置编译生成的可执行文件、库、脚本</li><li>install：安装空间（Install Space）：存放可执行文件，与上面有一定重复</li></ul><h3 id="2-创建工作空间"><a href="#2-创建工作空间" class="headerlink" title="2 .创建工作空间"></a>2 .创建工作空间</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建:"></a>创建:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/catkin_ws/src</span><br><span class="line">cd ~/catkin_ws/src //进入路径</span><br><span class="line">catkin_init_workspace//创建</span><br></pre></td></tr></table></figure><p>我们先创建一个src文件夹，然后进入该文件夹<br>第3行catkin_init_workspace意为将当前文件夹变为工作空间，使其拥有工作空间的属性</p><p>注：“~&#x2F;”意为当前用户名目录；“-p”意为递归创建目录，即直接创建多级目录。<br>src文件夹即代码空间，<strong>不能自行用别的名称代替</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/295b716b8c61ab30db59a08f20365092.png#pic_center" alt="img">可以看到创建了这么一个txt文件，说明创建工作空间成功。</p><h4 id="编译空代码的工作空间"><a href="#编译空代码的工作空间" class="headerlink" title="编译空代码的工作空间"></a>编译空代码的工作空间</h4><p>要编译工作空间，先要回到工作空间的根目录。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws //</span><br><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>使用catkin_make为编译指令，将src里的源码进行编译</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/200bc54200a700eaebfd9d1884fc8b08.png#pic_center" alt="img"></p><p>可以看到生成了build和devel两个新文件夹，devel存放了编译完成的内容。<br> 这里没有生成install文件夹，要生成install文件夹，输入<code>catkin_make install</code>：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a0d7c51839653be7056a87d3248cea71.png#pic_center" alt="在这里插入图片描述"></p><p>install中生成了可执行文件。</p><p>这样一个空的工作空间创建好了，并且空的代码空间（功能包）编译完成。</p><h3 id="3-创建功能包"><a href="#3-创建功能包" class="headerlink" title="3.创建功能包"></a>3.创建功能包</h3><p><strong>功能包</strong>是放置ROS源码的最小单元。</p><p>上面我们创建了一个空的工作空间，src文件夹里面没写东西，现在我们创建一个自己的功能包。</p><p><strong>注意同一工作空间下，不允许存在同名功能包；不同工作空间下，允许存在同名功能包</strong>。</p><p>指令格式：<strong>catkin_create_pkg <package_name> [depend1] [depend2] [depend3]</strong></p><p><package_name>为包名</p><p>[depend]为依赖，即指明编译的时候需要ROS中的其他功能包，如需要调用python、C++库，就要指明rospy、roscpp</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br></pre></td></tr></table></figure><p>创建后记得编译一下。</p><h3 id="4-设置并检查环境变量"><a href="#4-设置并检查环境变量" class="headerlink" title="4.设置并检查环境变量"></a>4.设置并检查环境变量</h3><p>编译完功能包后，为了运行，先<a href="https://so.csdn.net/so/search?q=%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">设置环境变量</a>，以便系统找到我们的工作空间和功能包。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><p>检查：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br></pre></td></tr></table></figure><h2 id="六、发布者Publisher的编程实现"><a href="#六、发布者Publisher的编程实现" class="headerlink" title="六、发布者Publisher的编程实现"></a>六、发布者Publisher的编程实现</h2><p>编程publisher 发送 message 产生topic，让海龟（sub）订阅实现功能。</p><p>进入src，创建功能包。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><h3 id="如何实现一个发布者程序："><a href="#如何实现一个发布者程序：" class="headerlink" title="如何实现一个发布者程序："></a>如何实现一个发布者程序：</h3><ul><li>初始化ROS节点</li><li>向ROS Master 注册节点信息，包括话题名和话题数据类型</li><li>创建消息数据</li><li>按照一定频率循环发布消息</li></ul><h3 id="具体操作如下："><a href="#具体操作如下：" class="headerlink" title="具体操作如下："></a>具体操作如下：</h3><ul><li><p>先在src目录下创建源文件（c++&#x2F;Python）</p></li><li><p>编写程序，修改cmakelist文件，回到工作空间编译并source</p></li><li><p>终端运行roscore，再打开一个终端运行rosrun +功能包下的程序</p></li><li><p>最终能看到小海龟按设定的程序运动</p></li></ul><h3 id="具体程序如下："><a href="#具体程序如下：" class="headerlink" title="具体程序如下："></a>具体程序如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"><span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">ros::Publisher turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line">    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、订阅者Sub的实现"><a href="#七、订阅者Sub的实现" class="headerlink" title="七、订阅者Sub的实现"></a>七、订阅者Sub的实现</h2><ul><li>初始化ROS节点</li><li>订阅需要的话题</li><li>循环等待话题消息，接收到消息后进入回调函数</li><li>在回调函数中完成消息处理</li></ul><p>操作和上面pub一样</p><h3 id="程序如下"><a href="#程序如下" class="headerlink" title="程序如下"></a>程序如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/node_handle.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/subscriber.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;turtle pose : x :%0.6f, y :%0.6f&quot;</span>,msg-&gt;x,msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ros初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line">    <span class="comment">//创建节点的句柄</span></span><br><span class="line">    ros::NodeHandle n ;</span><br><span class="line">    <span class="comment">//创建一个Subscriber，订阅名为/turtle/pose,注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span> , poseCallback) ;</span><br><span class="line">    <span class="comment">//循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序可以读取小海龟的位置</p><p>将pub和sub结合起来后的效果就是，海龟沿着设定的运动，然后sub获取他的位置</p><p>使用rqt-graph进行查看</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250919211003647.png" alt="image-20250919211003647"></p><h2 id="八、话题消息的定义和使用"><a href="#八、话题消息的定义和使用" class="headerlink" title="八、话题消息的定义和使用"></a>八、话题消息的定义和使用</h2><ul><li><p>Message 是一种自定义的数据结构，用于话题间的数据存储和传输</p></li><li><p>之前两节使用了Topic模型，我们先使用了Twist类型（geometry_msgs.msg库下的Twist类）的Message作为输入指令进行发布，接着使用了Pose类型（Turtlesim.msg库下的Pose类）的Message作为订阅消息进行接收。</p><p>  使用rosmsg show命令查看</p><p>  <img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920110325714.png" alt="image-20250920110325714"></p><p>  以上的<strong>Message</strong>消息都是预定义好的，当我们需要自定义消息该怎么做呢？</p></li></ul><p>如何操作：</p><ul><li><p>创建msg文件</p><p>  进入功能包目录里，新建msg文件夹，将所有自定义msg文件放入里面</p><p>  使用touch命令新建一个msg文件，将定义的东西放入msg中</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Person.msg//P要大写</span><br></pre></td></tr></table></figure><p>  <img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920105335067.png" alt="image-20250920105335067"></p></li><li><p>在package.xml添加功能包依赖</p><p>  将以下两行粘贴进入文件内</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><ul><li><p>在cmakelist中也要更改编译选项，把自定义msg文件添加到编译环境中</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package( ...... message_generation)</span><br><span class="line"></span><br><span class="line">add_message_files(FILES Person.msg)</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs)</span><br><span class="line"></span><br><span class="line">catkin_package( ...... message_runtime)</span><br></pre></td></tr></table></figure><p>  说明如下：</p><ul><li><p>因为在package.xml添加了功能包编译依赖，在CMakeList.txt里的find_package中也要加上对应的部分；</p></li><li><p>需要将定义的Person.msg作为消息接口，针对它做编译；<br>  需要指明编译这个消息接口需要哪些ROS已有的包；</p></li><li><p>有了34这两个配置才可将定义的msg编译成不同的程序文件</p></li><li><p>因为在package.xml添加了功能包执行依赖，在CMakeList.txt里的catkin_package中也要加上对应的部分</p></li></ul></li><li><p>最后回到工作空间进行编译</p></li></ul><h2 id="九、Servce模式的编程与使用"><a href="#九、Servce模式的编程与使用" class="headerlink" title="九、Servce模式的编程与使用"></a>九、Servce模式的编程与使用</h2><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920173350676.png" alt="image-20250920173350676"></p><p>Sever端是海龟仿真器节点，Client端是等待实现的节点，产生Request的请求，发送给Sever端。Sever端接受请求后产生一只海龟，并返回Response。中间传输的数据结构为定义好的turtlesim：：Spawn。</p><ul><li><p>老样子，创建一个learing_servce的pkg，添加必要的依赖</p></li><li><p>新建一个c++文件，放入src目录下</p></li><li><p>更改cmakelist文件的编译选项，编译文件</p></li><li><p>开启roscore，进行rosrun，实现功能</p><h3 id="程序如下-1"><a href="#程序如下-1" class="headerlink" title="程序如下"></a>程序如下</h3>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, </span><br><span class="line"> srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spwan turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920165919601.png" alt="image-20250920165919601"></p></li></ul><p>启动turle_spawn后，可以看到先是等待service应答</p><p>随后开启turtlrsim节点后，服务应答，就在对应位置添加了一个新的小海龟</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920170115886.png" alt="image-20250920170115886"></p><h2 id="十、服务端Sever的编程实现"><a href="#十、服务端Sever的编程实现" class="headerlink" title="十、服务端Sever的编程实现"></a>十、服务端Sever的编程实现</h2><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250920174015847.png" alt="image-20250920174015847"></p><p>Server端本身是进行模拟海龟运动的命令端，它的实现是通过给海龟发送速度（Twist）的指令，来控制海龟运动（本身通过Topic实现）。</p><p>Client端相当于海龟运动的开关，其发布Request来控制Server端。<br>通过自定义名为 &#x2F;turtle_command 的Service实现，中间传输消息的数据类型为std_srvs::Trigger（一种针对服务标准std_srvs下的数据定义）来通信。Trigger意为触发，通过Trigger信号来触发Server端的运动指令。<br>Server端接收这个Trigger信号后，可控制其是否要给海龟发送Twist指令，同时给Client发送Response反馈告诉它海龟的运动状态</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b71bbe429ce84281c88ef0c910dd78f8.png#pic_center" alt="img"></p><p>开启rosmaster，turtlesim之后</p><p> 接着我们使用<code>rosservice call ...</code>请求海龟动起来，再打开一个终端。<br> （输入完 &#x2F;turtle_command 后敲个空格再用Tab键可自动填充空指令内容）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /turtle_command <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>就可以看到海龟动起来了</p><h2 id="十一、服务数据srv的使用"><a href="#十一、服务数据srv的使用" class="headerlink" title="十一、服务数据srv的使用"></a>十一、服务数据srv的使用</h2><p>在第8节我们讲解了话题消息msg的定义与使用，在第8节的例子中我们曾自定义了一个消息类型“Person”以发布个人信息，Publisher发布个人信息，Subscriber接收个人信息。</p><p>这个例子中，Publisher会不断地发信息，Subscriber不停地接数据，一开动就停不下来了，也是topic模式的缺陷。</p><p>本节我们使用Service模式用自定义的服务数据srv来实现，我们希望Request一次才发一次信息来显示。</p><h3 id="创建srv文件"><a href="#创建srv文件" class="headerlink" title="创建srv文件"></a>创建srv文件</h3><p>在pkg功能包目录下创建srv文件夹，并使用touch命令生成.srv文件</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922190659468.png" alt="image-20250922190659468"></p><p>在文件中写入数据结构的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string name</span><br><span class="line">uint8 sex</span><br><span class="line">uint8 age</span><br><span class="line"></span><br><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male = 1</span><br><span class="line">uint8 female = 2</span><br><span class="line">---</span><br><span class="line">string result</span><br><span class="line">//与之前Person.msg不同的是，多了破折号下面这个Response结果，上面的是Request内容。</span><br><span class="line">//定义好srv数据接口后，就可以根据这个定义用C++或Python编译</span><br></pre></td></tr></table></figure><h3 id="添加功能包依赖"><a href="#添加功能包依赖" class="headerlink" title="添加功能包依赖"></a>添加功能包依赖</h3><p>由于此srv是自定义的，最初创建的时候没有添加依赖，所以要手动修改package.xml文件添加依赖。找到文件，把下面复制进去就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">//添加编译依赖</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br><span class="line">//添加执行依赖</span><br></pre></td></tr></table></figure><h3 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h3><p>打开CMakeLists.txt，添加编译选项，才能顺利的把srv文件编译出来。</p><p>大致上为四条，找到对应的部分进行更改即可。</p><p>每一部分都有注释在上方进行介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package( ...... message_generation)</span><br><span class="line"></span><br><span class="line">add_service_files(FILES Person.srv)</span><br><span class="line">generate_messages(DEPENDENCIES std_msgs)</span><br><span class="line"></span><br><span class="line">catkin_package( ...... message_runtime)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还得把自己写的cpp文件添加进去编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_executable(person_server src/person_server.cpp)</span><br><span class="line">target_link_libraries(person_server $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_server $&#123;PROJECT_NAME&#125;_gencpp)</span><br><span class="line"></span><br><span class="line">add_executable(person_client src/person_client.cpp)</span><br><span class="line">target_link_libraries(person_client $&#123;catkin_LIBRARIES&#125;)</span><br><span class="line">add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp)</span><br></pre></td></tr></table></figure><p>第三项是添加依赖项，因为代码涉及到动态生成，我们需要将可执行文件与动态生成的程序产生依赖关系。<br><strong>注：这里添加的依赖项用到的是gencpp包，是一个C++用的ROS message 和 service 生成器，以依赖动态生成的cpp文件</strong>。</p><h3 id="最后，编译并运行"><a href="#最后，编译并运行" class="headerlink" title="最后，编译并运行"></a>最后，编译并运行</h3><p>运行rosmaster，及其功能包，不再重复。</p><p>可以看到运行Server后，启动Client会发一次人物信息，在Server端看到，看到后反馈给Client确认后终止这次发送行为。<br>先运行Client的话则会一直等待Server端接收，直到Server端启动接收到信息</p><h2 id="十二、参数的使用与编程"><a href="#十二、参数的使用与编程" class="headerlink" title="十二、参数的使用与编程"></a>十二、参数的使用与编程</h2><ul><li><p>至此我们学习了ROS中的两种核心通信机制：Topic（话题）模式 和 Service（服务）模式。</p></li><li><p>Topic中的Publisher、Subscriber，Service中的Client、Server，消息类型msg、srv以及它们的自定义数据类型。 </p></li><li><p>这次讲讲参数的使用</p></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在ROS Master中，存在一个参数服务器（Parameter Server），它是一个全局字典，即一个全局变量的存储空间，用来保存各个节点的配置参数。各个节点都可以对参数进行全局访问。</p><h3 id="创建pkg"><a href="#创建pkg" class="headerlink" title="创建pkg"></a>创建pkg</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Ros_WorkSpace/src</span><br><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure><h3 id="rosparam使用"><a href="#rosparam使用" class="headerlink" title="rosparam使用"></a>rosparam使用</h3><p>在ROS中，参数文件常以YAML文件的格式保存</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922194609158.png" alt="image-20250922194609158"></p><p>打开海龟节点后使用list命令看一下：</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922194738800.png" alt="image-20250922194738800"></p><p>可以使用get命令获取某个参数值</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam get /turtlesim/background_b </span><br></pre></td></tr></table></figure><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922194923502.png" alt="image-20250922194923502"></p><p>也可以更改这些参数，使用set命令，随后使用get查看到已经更改。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922195108210.png" alt="image-20250922195108210"></p><p>但是，实际海龟背景尚未改变，发送一个clear的空内容服务请求。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922195238238.png" alt="image-20250922195238238"></p><p>这样子命令行更改有点麻烦，可以导出参数文件，更改后再load回去。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosparam dump param.yaml</span><br><span class="line">//导出参数，并保存为param.yaml文件</span><br></pre></td></tr></table></figure><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922195757467.png" alt="image-20250922195757467"></p><p>打开后，更改参数然后保存。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922195829768.png" alt="image-20250922195829768"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam load param.yaml</span><br></pre></td></tr></table></figure><p>随后，导入参数，再clear一下，可以看到颜色更改了。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922200000961.png" alt="image-20250922200000961"></p><p>其他的命令自己可以尝试。</p><h3 id="利用程序来使用参数"><a href="#利用程序来使用参数" class="headerlink" title="利用程序来使用参数"></a>利用程序来使用参数</h3><p>程序如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/turtlesim/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用服务，刷新背景颜色</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">ros::ServiceClient clear_background = node.<span class="built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">std_srvs::Empty srv;</span><br><span class="line">clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加cmake编译选项，不再重复。</p><p>运行后，更改了。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250922205135270.png" alt="image-20250922205135270"></p><h2 id="十三、launch文件的使用"><a href="#十三、launch文件的使用" class="headerlink" title="十三、launch文件的使用"></a>十三、launch文件的使用</h2><p>上文中，启动一个ros节点需要使用rosrun命令，每次启动都有打开一个新的终端，十分麻烦。</p><p>通过编写launch文件，将多个节点的内容写入进去，就可以一次性开启多个节点。</p><ul><li>launch文件可以放在任意一个软件包的目录下</li><li>启动launch文件时自动运行roscore，启动rosmaseter。</li><li>必须按照launch文件内容的格式进行编写，&#x2F;为结尾。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line"><span class="comment">//节点1</span></span><br><span class="line">        &lt;node pkg=<span class="string">&quot;learning_service&quot;</span> type=<span class="string">&quot;turtle_spawn&quot;</span> name=<span class="string">&quot;turtle_spawn&quot;</span> /&gt;</span><br><span class="line">    <span class="comment">//节点2</span></span><br><span class="line">        &lt;node pkg=<span class="string">&quot;turtlesim&quot;</span> type=<span class="string">&quot;turtlesim_node&quot;</span> name=<span class="string">&quot;turtlesim_node&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/launch&gt;</span><br></pre></td></tr></table></figure><p>在launch文件中，为一个节点添加 **launch-prefix&#x3D;”gnome-terminal-e”**属性，可以让节点单独运行在一个独立终端中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;node pkg=<span class="string">&quot;learning_service&quot;</span> type=<span class="string">&quot;turtle_spawn&quot;</span> name=<span class="string">&quot;turtle_spawn&quot;</span> launch-prefix=<span class="string">&quot;gnome-terminal-e&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="十四、Ros机器人运动控制"><a href="#十四、Ros机器人运动控制" class="headerlink" title="十四、Ros机器人运动控制"></a>十四、Ros机器人运动控制</h2><p>在上面的基本实验中，我们掌握了基本的话题消息订阅发布、客户端服务端服务发送。</p><p>现在，可以添加机器人仿真环境，利用ros来实验控制机器人运行了。</p><h3 id="安装机器人仿真环境"><a href="#安装机器人仿真环境" class="headerlink" title="安装机器人仿真环境"></a>安装机器人仿真环境</h3><p>打开src目录，下载仿真环境pkg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/6-robot/wpr_simulation.git</span><br></pre></td></tr></table></figure><p>运行包内的安装程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Ros_WorkSpace/wpr_simulation/scrips</span><br><span class="line">./install_for_noetic.sh</span><br></pre></td></tr></table></figure><p>安装完成后，回到workspace编译（source和编译再后文中默认进行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch wpr_simulation wpb_simple.launch</span><br></pre></td></tr></table></figure><p>可以看到一个仿真界面</p><h3 id="创建pkg，编写程序实现基本的运动控制"><a href="#创建pkg，编写程序实现基本的运动控制" class="headerlink" title="创建pkg，编写程序实现基本的运动控制"></a>创建pkg，编写程序实现基本的运动控制</h3><p>创建vel_pkg并添加roscpp rospy geometry_msgs依赖</p><p>添加vel_node函数，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;vel_node&quot;</span>);</span><br><span class="line"><span class="comment">//创建句柄</span></span><br><span class="line">    ros::NodeHandle n ;</span><br><span class="line"><span class="comment">//定义发布对象vel_pub</span></span><br><span class="line">    ros::Publisher vel_pub = </span><br><span class="line">    <span class="comment">//发布话题，类型是geo内的twist，话题名叫cmd_vel</span></span><br><span class="line">    n.advertise&lt;geometry_msgs::<span class="built_in">Twist</span>(<span class="string">&quot;/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//定义数据类型 </span></span><br><span class="line">    geometry_msgs::Twist vel_msg;</span><br><span class="line"></span><br><span class="line">    vel_msg.linear.x = <span class="number">0</span>;</span><br><span class="line">    vel_msg.linear.y = <span class="number">0</span>;</span><br><span class="line">    vel_msg.linear.z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vel_msg.angular.x = <span class="number">0</span>;</span><br><span class="line">    vel_msg.angular.y = <span class="number">0</span>;</span><br><span class="line">    vel_msg.angular.z = <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="comment">//开启while循环，不断发布消息</span></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在cmakelist中找到这两个选项，复制并取消注释，里面名字更改成自己的c++文件名</p><p>经典操作了，以后不再赘述</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250923123719319.png" alt="image-20250923123719319"></p><p>编译运行后，就可以看到仿真里面的机器人按照你的程序进行运动了。</p><h2 id="十五、激光雷达"><a href="#十五、激光雷达" class="headerlink" title="十五、激光雷达"></a>十五、激光雷达</h2><h3 id="TOF激光雷达"><a href="#TOF激光雷达" class="headerlink" title="TOF激光雷达"></a>TOF激光雷达</h3><p>雷达分为激光发射和接受两个模块，通过激光的发射与接收能测定障碍物的距离，再不断旋转雷达，就能测定周围的环境。</p><p>只要激光发射接收频率足够快，旋转速度足够快，就能实时得到周围环境。</p><p>而在ros中Rviz，我们得到的是一个激光雷达的点阵图。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924114550648.png" alt="image-20250924114550648"></p><h3 id="Rviz"><a href="#Rviz" class="headerlink" title="Rviz"></a>Rviz</h3><p>全名叫做Robot Visualization Tool ，是一个可视化工具。可以可视化传感器的数据，机器人运算处理的中间结果，比如显示路径规划，目标框选。</p><h4 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h4><ul><li><p>启动仿真程序后，在终端中输入rviz。<img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924115406006.png" alt="image-20250924115406006"></p></li><li><p>修改左边界面显示，左下角add RobotModel和LaserScan，如图（如果没有机器人模型的话就source一下再打开rviz）</p></li></ul><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924120357814.png" alt="image-20250924120357814">****</p><ul><li><p>这一排红色点阵就是雷达获取的数据，可以在仿真环境中添加障碍物来查看rviz的显示</p><p>  <img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924121504960.png" alt="image-20250924121504960"></p></li><li><p>可以导出此次的配置文件，然后下次打开rviz后再open配置文件。点击左上角的flies目录就可以看到</p></li></ul><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul><li>rviz只是一个数据可视化界面，用于显示机器人获取的数据，无论他是仿真机器人还是真实的机器人</li><li>可以通过launch文件来自动配置rviz的参数</li><li></li></ul><h4 id="Ros中激光雷达的消息包格式"><a href="#Ros中激光雷达的消息包格式" class="headerlink" title="Ros中激光雷达的消息包格式"></a>Ros中激光雷达的消息包格式</h4><p>在roswiki官网中可以打开sensor_msgs&#x2F;LaserScan Message，注释翻译成中文</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924121815175.png" alt="image-20250924121815175"></p><p>可以在终端中显示消息类型</p><p>输入rostopic echo &#x2F;scan –noarr</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924121950186.png" alt="image-20250924121950186"></p><h3 id="用c-实现获取激光雷达"><a href="#用c-实现获取激光雷达" class="headerlink" title="用c++实现获取激光雷达"></a>用c++实现获取激光雷达</h3><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924195957070.png" alt="image-20250924195957070"></p><ul><li><p>构建一个新的软件包，包名为lidar_pkg</p></li><li><p>新建一个节点，lidar_node</p></li><li><p>在节点中，向ros大管家nodehandle申请订阅话题，并设置回调函数为lidarcallback（）</p></li><li><p>构建回调函数，接受并处理数据</p></li><li><p>调用ros_info()显示雷达检测到的前方障碍物距离</p><p>  函数如下：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lidar_Callback</span><span class="params">(<span class="type">const</span> sensor_msgs::LaserScan msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> fMidDist = msg.ranges[<span class="number">180</span>];</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;前方测距 ranges[180] = %f 米&quot;</span>,fMidDist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;lidar_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle n ;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber lidar_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/scan&quot;</span>, <span class="number">10</span>, &amp;lidar_Callback);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>编译运行后，再打开仿真工具，移动前方的书架，可以看到距离的变化</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924205150384.png" alt="image-20250924205150384"></p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924205207354.png" alt="image-20250924205207354"></p><h2 id="十六、实现简单的避障控制"><a href="#十六、实现简单的避障控制" class="headerlink" title="十六、实现简单的避障控制"></a>十六、实现简单的避障控制</h2><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250924205557332.png" alt="image-20250924205557332"></p><p>在上一节的基础上修改程序就可以了</p><ul><li>发布速度控制话题&#x2F;cmd_vel</li><li>构建速度控制消息包，vel_cmd用于数据传输</li><li>根据激光雷达的测距值，调整机器人运动速度，避开障碍</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher vel_pub ;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lidar_Callback</span><span class="params">(<span class="type">const</span> sensor_msgs::LaserScan msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> fMidDist = msg.ranges[<span class="number">180</span>];</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;前方测距 ranges[180] = %f 米&quot;</span>,fMidDist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    geometry_msgs::Twist vel_cmd;</span><br><span class="line">    <span class="keyword">if</span> (fMidDist &lt; <span class="number">1.5</span>) &#123;</span><br><span class="line">        vel_cmd.angular.z = <span class="number">0.3</span>;</span><br><span class="line">        n=<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        vel_cmd.linear.x = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vel_pub.<span class="built_in">publish</span>(vel_cmd);</span><br><span class="line">  <span class="comment">//如果没有速度的输入，机器人会按照最近一次的速度运动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;lidar_node&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle n ;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber lidar_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/scan&quot;</span>, <span class="number">10</span>, &amp;lidar_Callback);</span><br><span class="line"></span><br><span class="line">                    vel_pub  = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    ros::<span class="built_in">spin</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十七、Ros中IMU的使用"><a href="#十七、Ros中IMU的使用" class="headerlink" title="十七、Ros中IMU的使用"></a>十七、Ros中IMU的使用</h2><h3 id="Imu-Message"><a href="#Imu-Message" class="headerlink" title="Imu Message"></a>Imu Message</h3><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925105143048.png" alt="image-20250925105143048"></p><ul><li>angular_veloity ——————x,y,z三轴的旋转速度</li><li>liner——acceleration——————xyz三轴矢量加速度</li><li>orientation——————xyz经处理后的偏移量，数据类型是Quaternion，包含float x，y ，z ，w。四元数描述。</li></ul><h3 id="C-实现imu数据获取"><a href="#C-实现imu数据获取" class="headerlink" title="C++实现imu数据获取"></a>C++实现imu数据获取</h3><p>Ros官方给出了三个话题</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925110052247.png" alt="image-20250925110052247"></p><ul><li><p>六轴原始数据</p></li><li><p>六轴原始数据和融合后的四元数姿态描述</p></li><li><p>加上磁力计的九轴数据</p><p>  <strong>Cpp实现步骤</strong>：</p></li><li><p>创建一个新的pkg</p></li><li><p>建立节点，imu_node</p></li><li><p>编程构建imu_node,利用回调函数对imu的数据进行处理</p></li><li><p>使用tf工具转换数据，并屏幕打印</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IMUCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::Imu msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测消息包中四元数数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(msg.orientation_covariance[<span class="number">0</span>] &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 四元数转成欧拉角</span></span><br><span class="line">    <span class="function">tf::Quaternion <span class="title">quaternion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.x,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.y,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.z,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.w</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="type">double</span> roll, pitch, yaw;</span><br><span class="line">    tf::<span class="built_in">Matrix3x3</span>(quaternion).<span class="built_in">getRPY</span>(roll, pitch, yaw);</span><br><span class="line">    <span class="comment">// 弧度换算成角度</span></span><br><span class="line">    roll = roll*<span class="number">180</span>/M_PI;</span><br><span class="line">    pitch = pitch*<span class="number">180</span>/M_PI;</span><br><span class="line">    yaw = yaw*<span class="number">180</span>/M_PI;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;滚转= %.0f 俯仰= %.0f 朝向= %.0f&quot;</span>, roll, pitch, yaw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;demo_imu_data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">// 订阅 IMU 的数据话题</span></span><br><span class="line">    ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;imu/data&quot;</span>, <span class="number">100</span>, IMUCallback);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现与运动控制的结合"><a href="#实现与运动控制的结合" class="headerlink" title="实现与运动控制的结合"></a>实现与运动控制的结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher vel_pub ;</span><br><span class="line"><span class="comment">// IMU 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IMUCallback</span><span class="params">(<span class="type">const</span> sensor_msgs::Imu msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测消息包中四元数数据是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(msg.orientation_covariance[<span class="number">0</span>] &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 四元数转成欧拉角</span></span><br><span class="line">    <span class="function">tf::Quaternion <span class="title">quaternion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.x,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.y,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.z,</span></span></span><br><span class="line"><span class="params"><span class="function">        msg.orientation.w</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="type">double</span> roll, pitch, yaw;</span><br><span class="line">    tf::<span class="built_in">Matrix3x3</span>(quaternion).<span class="built_in">getRPY</span>(roll, pitch, yaw);</span><br><span class="line">    <span class="comment">// 弧度换算成角度</span></span><br><span class="line">    roll = roll*<span class="number">180</span>/M_PI;</span><br><span class="line">    pitch = pitch*<span class="number">180</span>/M_PI;</span><br><span class="line">    yaw = yaw*<span class="number">180</span>/M_PI;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;滚转= %.0f 俯仰= %.0f 朝向= %.0f&quot;</span>, roll, pitch, yaw);</span><br><span class="line"><span class="comment">//此处可以设计pid算法</span></span><br><span class="line">    <span class="type">double</span> t_yaw = <span class="number">90</span>;</span><br><span class="line">    <span class="type">float</span> kp ,ki ,kd ;</span><br><span class="line">    <span class="type">double</span> error = t_yaw - yaw ;</span><br><span class="line"></span><br><span class="line">    geometry_msgs::Twist vel_cmd;</span><br><span class="line">    kp = <span class="number">0.02</span> ;</span><br><span class="line">    vel_cmd.angular.z = error *kp ;</span><br><span class="line">    vel_cmd.linear.x = <span class="number">0.1</span> ;</span><br><span class="line">    vel_pub.<span class="built_in">publish</span>(vel_cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;demo_imu_data&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">// 订阅 IMU 的数据话题</span></span><br><span class="line">    ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;imu/data&quot;</span>, <span class="number">100</span>, IMUCallback);</span><br><span class="line">        vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;cmd_vel&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十八、栅格地图"><a href="#十八、栅格地图" class="headerlink" title="十八、栅格地图"></a>十八、栅格地图</h2><p>假设地图上有两个障碍物，以俯视观察他。将地图用大小相同的方格代替，被占据的格子（哪怕只占据一点）涂上黑色，未被占据的栅格涂上白色。如图</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925193257940.png" alt="image-20250925193257940"></p><p><strong>切换栅格的大小可以让障碍物的表示更加精准，理论上可以无限逼近实际的大小</strong>。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925193415756.png" alt="image-20250925193415756"></p><ul><li>一个小正方形的边长（栅格边长）即为<strong>地图分辨率</strong>。</li><li>将黑色格子标记为1，空白格子为0，这样整个地图就可以以数组的形式存储数据来表示。</li></ul><h3 id="Ros栅格地图消息的数据结构"><a href="#Ros栅格地图消息的数据结构" class="headerlink" title="Ros栅格地图消息的数据结构"></a>Ros栅格地图消息的数据结构</h3><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925193836624.png" alt="image-20250925193836624"></p><p>info的包含如下：</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925194150699.png" alt="image-20250925194150699"></p><h3 id="C-编写节点"><a href="#C-编写节点" class="headerlink" title="C++编写节点"></a>C++编写节点</h3><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925194447759.png" alt="image-20250925194447759"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;map_pub_node&quot;</span>);</span><br><span class="line">    ros::NodeHandle n ;</span><br><span class="line">    ros::Publisher pub = n.<span class="built_in">advertise</span>&lt;nav_msgs::OccupancyGrid&gt;(<span class="string">&quot;/map&quot;</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">1</span>)</span> </span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::ok) &#123;</span><br><span class="line">      <span class="comment">//定义数据类型</span></span><br><span class="line">        nav_msgs::OccupancyGrid msg ;</span><br><span class="line">      <span class="comment">//设置地图参数</span></span><br><span class="line">        msg.header.frame_id = <span class="string">&quot;map&quot;</span>;</span><br><span class="line">        msg.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        msg.info.origin.position.x = <span class="number">0</span>;</span><br><span class="line">        msg.info.origin.position.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        msg.info.resolution = <span class="number">1.0</span>;</span><br><span class="line">        msg.info.width = <span class="number">4</span>;</span><br><span class="line">        msg.info.height = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        msg.data.<span class="built_in">resize</span>(<span class="number">8</span>);<span class="comment">//将八个格子的值清0</span></span><br><span class="line"><span class="comment">//给地图赋值</span></span><br><span class="line">        msg.data[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        msg.data[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">        msg.data[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        msg.data[<span class="number">3</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">        r.<span class="built_in">sleep</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动roscore，启动节点，启动rviz</p><p>添加起始点（Axes）和Map，topic选择写好的&#x2F;map话题。可以看到地图按照我们定义的样子展现出来。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925201732674.png" alt="image-20250925201732674"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.info.origin.position.x = 2.0;</span><br><span class="line">msg.info.origin.position.y = 1.0;</span><br></pre></td></tr></table></figure><p>如果更改了上面的数值，他们不再为0，就会出现这样子的情况：</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250925202124104.png" alt="image-20250925202124104"></p><h2 id="十九、SLAM"><a href="#十九、SLAM" class="headerlink" title="十九、SLAM"></a>十九、SLAM</h2><p>全程是simultaneous localization and mapping，同时定位与地图创建。</p><p><strong>定位</strong>：是指机器人确定自己的位置。</p><h3 id="Slam的原理"><a href="#Slam的原理" class="headerlink" title="Slam的原理"></a>Slam的原理</h3><p>如何创建地图呢？？</p><p>先选定一个原点作为参照系，建立坐标轴，通过记录当前观测点与对应参照物的坐标，改变不同观测点，将多次记录的坐标进行比对，将参照物重合构建出一张完整的地图。</p><p><strong>在Ros中如何实现建图的功能呢</strong></p><p>首先，Ros是地图是栅格地图，机器人放置在环境中，没有开启传感器感知周围时，所有格子的值均为-1，涂上灰色。</p><p>假设此时机器人开启了雷达扫描功能，激光发射出去穿过的格子都标记为0，涂上白色，代表没有障碍物。直到激光撞到障碍物，反射回来，这个格子标记为100，涂上黑色。这样子就能得到当前观测点的周围障碍物情况，改变观测点后，又进行一次扫描，标记出周围的情况。将两次的标记情况进行特征重合，构建出局部的地图。不断重复这个过程，就可以得到一副完整的地图了。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926185458750.png" alt="image-20250926185458750"></p><h3 id="Ros中通过c-实现Slam"><a href="#Ros中通过c-实现Slam" class="headerlink" title="Ros中通过c++实现Slam"></a>Ros中通过c++实现Slam</h3><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926185810196.png" alt="image-20250926185810196"></p><p>激光雷达发送数据到slam节点进行处理（建图算法），在发布map话题让rviz可视化界面订阅，就可以显示地图出来了。</p><p>Slam算法节点在ros中有提供，叫做Hector_Mapping节点。不用重复造轮子。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926200118226.png" alt="image-20250926200118226"></p><p>通过运行前三条指令可以开启slam的扫描功能，在rviz界面中add选项添加机器人model和map地图</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926201134977.png" alt="image-20250926201134977"></p><p>第四行指令可以开启一个图像化界面来控制机器人运动</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926201231220.png" alt="image-20250926201231220"></p><p>控制机器人移动，建模成功。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926201452881.png" alt="image-20250926201452881"></p><h3 id="launch文件使用"><a href="#launch文件使用" class="headerlink" title="launch文件使用"></a>launch文件使用</h3><p>操作这么多有点麻烦，现在编写一个launch文件来一次性开启这些程序。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926204242519.png" alt="image-20250926204242519"></p><p>第一条语法是包含另一个launch文件的写法，￥（)用于查找括号下软件包的目录，后面接着具体文件路径。</p><p>其余三条，之前已经说明过。</p><p>编译运行。成功。</p><p>在rviz中导出配置好的rviz，放入pkg文件夹里的rviz目录下，并命名slam.rviz。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rviz -d ~/Ros_WorkSpace/src/slam_pkg/rviz/slam.rviz</span><br></pre></td></tr></table></figure><p>可以在终端输入这段代码打开rviz后自动加载配置文件，也可以打开rviz后再手动选择加载。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926205145607.png" alt="image-20250926205145607"></p><p>可以在launch中添加参数args ，通过rviz来自动加载rviz的配置。</p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20250926205323599.png" alt="image-20250926205323599"></p><p>这样子就算自动配置好launch文件了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派ROS小车的搭建</title>
      <link href="/year/11/01/%E6%A0%91%E8%8E%93%E6%B4%BEROS%E5%B0%8F%E8%BD%A6/"/>
      <url>/year/11/01/%E6%A0%91%E8%8E%93%E6%B4%BEROS%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派ROS小车"><a href="#树莓派ROS小车" class="headerlink" title="树莓派ROS小车"></a>树莓派ROS小车</h1><h2 id="安装树莓派相关ROS环境"><a href="#安装树莓派相关ROS环境" class="headerlink" title="安装树莓派相关ROS环境"></a>安装树莓派相关ROS环境</h2><h3 id="安装ubuntu-mate系统"><a href="#安装ubuntu-mate系统" class="headerlink" title="安装ubuntu mate系统"></a>安装ubuntu mate系统</h3><h4 id="下载ubuntu-mate20-04镜像"><a href="#下载ubuntu-mate20-04镜像" class="headerlink" title="下载ubuntu mate20.04镜像"></a>下载ubuntu mate20.04镜像</h4><ul><li><p>百度搜索ubuntu mate，进入download界面，拉倒最底下</p></li><li><p>选择Browse archive and previous device ports <a href="https://releases.ubuntu-mate.org/">https://releases.ubuntu-mate.org/</a></p></li></ul><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023165941768.png" alt="image-20251023165941768"></p><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023170041982.png" alt="image-20251023170041982"></p><ul><li>随后进入20.04 arm64 ，下载<a href="https://releases.ubuntu-mate.org/20.04/arm64/ubuntu-mate-20.04.1-desktop-arm64+raspi.img.xz">https://releases.ubuntu-mate.org/20.04/arm64/ubuntu-mate-20.04.1-desktop-arm64+raspi.img.xz</a></li></ul><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023170222972.png" alt="image-20251023170222972"></p><h4 id="制作并烧录到SD卡里"><a href="#制作并烧录到SD卡里" class="headerlink" title="制作并烧录到SD卡里"></a>制作并烧录到SD卡里</h4><ul><li>前往树莓派官网下载他的烧录工具</li></ul><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023170412766.png" alt="image-20251023170412766"></p><ul><li><p>第一个选择烧录的设备型号（树莓派4B），第二个选择自己下载的ubuntu mate ，第三个选择烧录的位置，选择你的sd卡。随后点击烧录即可</p><p>  <img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023170559247.png" alt="image-20251023170559247"></p></li><li><p>可以提前配置一下用户名、网络啥的。</p></li></ul><h4 id="进入树莓派ubuntu-mate系统"><a href="#进入树莓派ubuntu-mate系统" class="headerlink" title="进入树莓派ubuntu mate系统"></a>进入树莓派ubuntu mate系统</h4><p>把sd卡插入树莓派，随后插电开机。使用micro HDMI线连上显示器。</p><p>进行基本的配置，设置用户名密码、网络连接。</p><p>更换清华源，不再赘述。</p><p>安装network工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure><p>查看树莓派的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023171300357.png" alt="image-20251023171300357"></p><p>将树莓派和主机放在同一局域网，测试ping通，在主机终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 10.43.234.55(树莓派ip)</span><br></pre></td></tr></table></figure><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023171505520.png" alt="image-20251023171505520"></p><p>这样就是ping通了，可以使用远程连接。</p><h3 id="树莓派配置远程连接"><a href="#树莓派配置远程连接" class="headerlink" title="树莓派配置远程连接"></a>树莓派配置远程连接</h3><h4 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h4><p><strong>直接终端连接</strong>：</p><p>在ubuntu主机里，下载remmina连接工具。</p><p>ping通了之后，终端可以直接连，但是使用remmina工具更方便。</p><p>终端输入ssh &lt;树莓派用户名&gt;@&lt;树莓派IP地址&gt;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shh pi@10.43.234.55</span><br></pre></td></tr></table></figure><p><img src="/home/chonqin/.config/Typora/typora-user-images/image-20251023171926032.png" alt="image-20251023171926032"></p><p>输入树莓派密码后就可以连接上了。</p><p><strong>利于remmina</strong>：</p><p>这是linux下一个软件能储存信息，方便连接：</p><p>点击左上角加好，再输入ip 密码啥的就可以连接了。</p><p><img src="/assets/image-20251025164851196.png" alt="image-20251025164851196"></p><h4 id="利用TigerVNC进行远程桌面连接"><a href="#利用TigerVNC进行远程桌面连接" class="headerlink" title="利用TigerVNC进行远程桌面连接"></a>利用TigerVNC进行远程桌面连接</h4><p>先给ubuntu mate换个桌面，自带的mate桌面有点卡。</p><p>更换xfce4桌面并卸载自带mate桌面不赘述了（自行搜索）。</p><p><img src="/assets/image-20251025165110719.png" alt="image-20251025165110719"></p><h3 id="个人IP"><a href="#个人IP" class="headerlink" title="个人IP"></a>个人IP</h3><p><code>校园网环境下</code>：</p><p>​PC有线连接校园网IP：10.43.173.38</p><p>​树莓派无线连接宿舍校园网IP：10.43.234.55</p><p><code>609wifi环境下</code>:</p><p>​PC有线连接校园网IP：10.43.173.38</p><p>​树莓派无线连接宿舍校园网IP：10.43.234.55</p><h3 id="sync同步文件的使用"><a href="#sync同步文件的使用" class="headerlink" title="sync同步文件的使用"></a>sync同步文件的使用</h3><p><strong>基本用法</strong>:</p><ul><li>路径在左边：意味着将左边同步到右边</li><li>路径在右边：同理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sync &lt;本地路径&gt; &lt;远程连接用户名&gt;@&lt;IP地址&gt;:&lt;远程路径&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意空格，路径写全不要用~</span></span><br></pre></td></tr></table></figure><p><strong>sync同步命令是一次性的，每次输入都很长，很麻烦，编写一个脚本来实现</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">树莓派目标目录</span></span><br><span class="line">REMOTE_DIR=/home/pi/pi_ws/src</span><br><span class="line"></span><br><span class="line">echo &quot;===============================&quot;</span><br><span class="line">echo &quot;  选择要同步的树莓派&quot;</span><br><span class="line">echo &quot;===============================&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示菜单</span></span><br><span class="line">index=1</span><br><span class="line">for name in &quot;$&#123;!PI_HOSTS[@]&#125;&quot;; do</span><br><span class="line">    echo &quot;$index. $name  ($&#123;PI_HOSTS[$name]&#125;)&quot;</span><br><span class="line">    names[$index]=$name</span><br><span class="line">    ((index++))</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户输入编号</span></span><br><span class="line">read -p &quot;请输入编号 (1-$((index-1))): &quot; choice</span><br><span class="line"></span><br><span class="line">if [[ -z &quot;$&#123;names[$choice]&#125;&quot; ]]; then</span><br><span class="line">    echo &quot;无效的编号，退出。&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取选择的名称和IP</span></span><br><span class="line">SELECTED_NAME=$&#123;names[$choice]&#125;</span><br><span class="line">PI_HOST=$&#123;PI_HOSTS[$SELECTED_NAME]&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;已选择: $SELECTED_NAME ($PI_HOST)&quot;</span><br><span class="line">echo &quot;    本地目录:  $LOCAL_DIR/&quot;</span><br><span class="line">echo &quot;    目标目录:  $PI_USER@$PI_HOST:$REMOTE_DIR/&quot;</span><br><span class="line">echo &quot;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二次确认</span></span><br><span class="line">read -p &quot;确认执行同步吗？(y/n): &quot; confirm</span><br><span class="line">if [[ &quot;$confirm&quot; != &quot;y&quot; &amp;&amp; &quot;$confirm&quot; != &quot;Y&quot; ]]; then</span><br><span class="line">    echo &quot;已取消同步。&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查设备是否在线</span></span><br><span class="line">ping -c 1 -W 1 &quot;$PI_HOST&quot; &amp;&gt;/dev/null</span><br><span class="line">if [[ $? -ne 0 ]]; then</span><br><span class="line">    echo &quot;无法连接到 $PI_HOST，请检查网络。&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Rsync 同步</span></span><br><span class="line">rsync -avz --progress &quot;$&#123;LOCAL_DIR&#125;/&quot; &quot;$&#123;PI_USER&#125;@$&#123;PI_HOST&#125;:$&#123;REMOTE_DIR&#125;/&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;同步到 $SELECTED_NAME 完成&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--progress 命令可以中显示文件传输进度条，包括文件大小、已经传输的大小、传输速度和剩余时间</span></span><br></pre></td></tr></table></figure><ul><li>-a———&gt;保留文件属性并递归复制目录</li><li>-v———&gt;显示详细信息</li><li>-z———&gt;压缩数据，加快传输</li><li>–progress———&gt;显示每个文件传输进度</li></ul><h2 id="ROS与STM32间的通信"><a href="#ROS与STM32间的通信" class="headerlink" title="ROS与STM32间的通信"></a>ROS与STM32间的通信</h2><h3 id="完成hello-world"><a href="#完成hello-world" class="headerlink" title="完成hello world!"></a>完成hello world!</h3><p>首先，让STM32F407串口发送一个**”hello world!”**</p><p>linux下串口工具可以使用xTools：</p><p><img src="/assets/image-20251025165649697.png" alt="image-20251025165649697"></p><p>cutecom在我的环境下有显示的问题，不使用。</p><p>查询串口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/tty*</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20251025170343631.png" alt="image-20251025170343631"></p><p><strong>可以通过插拔来查找usb串口通道</strong></p><p>linux系统下串口无法使用问题：</p><ul><li>没有安装usb转ttl的驱动导致问题</li><li>没有给予usb权限</li></ul><p>解决方法：</p><ul><li>去下载对应芯片的驱动（ch340&#x2F;ch9102）,linux自带了cp210x的驱动</li><li>使用chmod给对应串口通道施加权限，没有权限无法运行。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 &lt;设备通道&gt;</span><br><span class="line">eg:</span><br><span class="line">chmod 777 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>ros串口发布节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/String.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serial/serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">serial::Serial ser;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ser.<span class="built_in">setPort</span>(<span class="string">&quot;/dev/ttyUSB0&quot;</span>);<span class="comment">//串口名称</span></span><br><span class="line">    ser.<span class="built_in">setBaudrate</span>(<span class="number">115200</span>);<span class="comment">//波特率</span></span><br><span class="line">    serial::Timeout to =   serial::Timeout::<span class="built_in">simpleTimeout</span>(<span class="number">100</span>);<span class="comment">//等待时间</span></span><br><span class="line">    ser.<span class="built_in">setTimeout</span>(to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ser.<span class="built_in">open</span>();<span class="comment">//打开串口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(serial::IOException&amp; e)&#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR_STREAM</span>(<span class="string">&quot;Unable to open port.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ser.<span class="built_in">isOpen</span>()) &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;/dev/ttyCH341USB0 is open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;/dev/ttyCH341USB0 open failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ROS初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;stm32_Serial_test01&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">//创建ROS发布者节点</span></span><br><span class="line">    ros::Publisher stm32_pub = nh.<span class="built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="string">&quot;stm32_data&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//串口相关配置</span></span><br><span class="line">    <span class="built_in">serial_init</span>();</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//设置循环速率</span></span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取缓冲区内的字节数</span></span><br><span class="line">        <span class="type">size_t</span> n = ser.<span class="built_in">available</span>();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义一个缓冲区，将数据存放在此</span></span><br><span class="line">            <span class="type">uint8_t</span> buffer[<span class="number">1024</span>];</span><br><span class="line">            n = ser.<span class="built_in">read</span>(buffer, n);</span><br><span class="line"></span><br><span class="line">            <span class="function">std::string <span class="title">received_data</span><span class="params">(buffer, buffer + n)</span></span>;  <span class="comment">// 将字节转成字符串</span></span><br><span class="line">            <span class="built_in">ROS_INFO_STREAM</span>(<span class="string">&quot;Received data: &quot;</span> &lt;&lt; received_data);</span><br><span class="line">            <span class="comment">//将接受到的内容封装为ROS消息，并发布消息出去</span></span><br><span class="line">            std_msgs::String msg;</span><br><span class="line">            msg.data = received_data;</span><br><span class="line">            stm32_pub.<span class="built_in">publish</span>(msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (received_data.<span class="built_in">find</span>(<span class="string">&quot;hello world!&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">                <span class="built_in">ROS_INFO</span>(<span class="string">&quot;STM32 sent: hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ser.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置stm32串口发送到上位机后，开启此节点，可以看到成功接收。</p><h2 id="编写键盘输入节点实现键盘控制小车移动"><a href="#编写键盘输入节点实现键盘控制小车移动" class="headerlink" title="编写键盘输入节点实现键盘控制小车移动"></a>编写键盘输入节点实现键盘控制小车移动</h2><h3 id="键盘输入节点"><a href="#键盘输入节点" class="headerlink" title="键盘输入节点"></a>键盘输入节点</h3><p>核心是如何读取键盘输入，然后转换成数据发送话题出去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------- 函数功能：从终端读取单个按键，不需要按回车 ----------- //</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">termios</span> oldt, newt;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端属性</span></span><br><span class="line">    <span class="built_in">tcgetattr</span>(STDIN_FILENO, &amp;oldt);</span><br><span class="line">    newt = oldt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭规范模式(ICANON)和回显(ECHO)，实现即时单字符读取</span></span><br><span class="line">    newt.c_lflag &amp;= ~(ICANON | ECHO);</span><br><span class="line">    <span class="built_in">tcsetattr</span>(STDIN_FILENO, TCSANOW, &amp;newt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取单个字符</span></span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复终端原设置</span></span><br><span class="line">    <span class="built_in">tcsetattr</span>(STDIN_FILENO, TCSANOW, &amp;oldt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 ROS 节点，节点名为 keyboard_ctrl_pub</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;keyboard_control&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Publisher，发布主题为 /cmd_vel，消息类型为 geometry_msgs::Twist</span></span><br><span class="line">    ros::Publisher cmd_pub = nh.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    geometry_msgs::Twist cmd;  <span class="comment">// 创建 Twist 消息对象</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 键盘控制说明 ===\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w: 前进 | s: 后退 | a: 左转 | d: 右转\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;空格: 停止 | q: 退出程序\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;====================\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环：持续读取键盘按键</span></span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">getch</span>();  <span class="comment">// 获取键盘输入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次先清零速度</span></span><br><span class="line">        cmd.linear.x = <span class="number">0.0</span>;</span><br><span class="line">        cmd.angular.z = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按键控制逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">            cmd.linear.x = <span class="number">0.5</span>;     <span class="comment">// 前进，线速度为 0.5 m/s</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">            cmd.linear.x = <span class="number">-0.5</span>;    <span class="comment">// 后退</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">            cmd.angular.z = <span class="number">1.0</span>;    <span class="comment">// 左转，角速度正方向</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">            cmd.angular.z = <span class="number">-1.0</span>;   <span class="comment">// 右转，角速度负方向</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            cmd.linear.x = <span class="number">0</span>;       <span class="comment">// 停止</span></span><br><span class="line">            cmd.angular.z = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 按 q 退出程序</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;退出程序\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布速度命令</span></span><br><span class="line">        cmd_pub.<span class="built_in">publish</span>(cmd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印调试信息</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;发布速度: linear=%.2f m/s, angular=%.2f rad/s&quot;</span>, cmd.linear.x, cmd.angular.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写了这个控制节点后，成功将数据利用话题的方式发布出去。</p><h3 id="通信节点"><a href="#通信节点" class="headerlink" title="通信节点"></a>通信节点</h3><p>前面写了键盘并且把</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
